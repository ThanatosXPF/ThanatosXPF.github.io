<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Ubuntu 16.04 cuda10.0 cudnn 7.4.1 tensorflow 1.13.1 环境配置</title>
      <link href="/2019/04/02/Ubuntu16.04+cuda10/"/>
      <url>/2019/04/02/Ubuntu16.04+cuda10/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>之前一段时间帮实验室的十几台电脑安装或者更新了Tensorflow环境，从最开始的安装 Cuda8.0 + Tensorflow 1.2.0 到前一段时间卸载 Cuda8.0 安装 Cuda10.0 和 Tensorflow 1.13.0。感觉有必要总结一下安装过程。</p><h2 id="卸载原有-nvidia-驱动以及-cuda">卸载原有 Nvidia 驱动以及 Cuda</h2><pre><code># sudo apt remove --purge nvidia*# sudo apt remove --purge cuda# sudo apt autoclean</code></pre><p>卸载完成后可以检查文件是否完全删除干净，路径 <code>/usr/local/</code> 如果没有看到 <code>cuda</code> 等文件夹则证明卸载完成。同时如果最初是使用的 deb 本地安装的 cuda，需要删除镜像源文件。</p><pre><code># cd /etc/apt/source.list.d# rm cuda*</code></pre><h2 id="禁用-nouveau">禁用 Nouveau</h2><p>只有在禁用 Nouveau 的情况下才能顺利安装 Nvidia 驱动。首先</p><pre><code># sudo vim /etc/modprobe.d/blacklist-nouveau.conf</code></pre><p>在最后一行加上</p><pre><code>blacklist nouveau</code></pre><p>可能这一步需要重启。（之前并没有遇到过这个对于重装环境的影响）</p><h2 id="安装新-cuda">安装新 Cuda</h2><p>这一步主要根据 <a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">NVIDIA 官方</a>的指导。对于 Cuda 10.0</p><pre><code># sudo dpkg -i cuda-repo-ubuntu1604-10-0-local-10.0.130-410.48_1.0-1_amd64.deb# sudo apt-key add /var/cuda-repo-&lt;version&gt;/7fa2af80.pub# sudo apt-get update# sudo apt-get install cuda</code></pre><p>安装结束后可以检测是否安装成功</p><pre><code># nvcc -Vnvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2018 NVIDIA CorporationBuilt on Sat_Aug_25_21:08:01_CDT_2018Cuda compilation tools, release 10.0, V10.0.130</code></pre><p>看到以上字样说明安装成功。</p><h2 id="安装-libcudnn">安装 libcudnn</h2><p>首先去官网下载相应 libcudnn 安装包，这里使用的 libcudnn 7.4.1，依次安装</p><pre><code>sudo dpkg -i libcudnn7_7.4.1.5-1+cuda10.0_amd64.debsudo dpkg -i libcudnn7-dev_7.4.1.5-1+cuda10.0_amd64.debsudo dpkg -i libcudnn7-doc_7.4.1.5-1+cuda10.0_amd64.deb</code></pre><h2 id="验证安装">验证安装</h2><p>输入命令 <code>nvidia-smi</code> ，如果输出显卡的信息则证明安装成功。若出现</p><pre><code># nvidia-smiFailed to initialize NVML: Driver/library version mismatch</code></pre><p>一般可以重启解决。但也可以尝试不重启的解决方法。我们可以尝试 unload 目前的驱动模块，load 正确版本的驱动。</p><pre><code># lsmod | grep nvidia</code></pre><p>可能会出现结果</p><pre><code>nvidia_uvm            634880  8nvidia_drm             53248  0nvidia_modeset        790528  1 nvidia_drmnvidia              12312576  86 nvidia_modeset,nvidia_uvm</code></pre><p>依次 unload 这些模块</p><pre><code>sudo rmmod nvidia_drmsudo rmmod nvidia_modesetsudo rmmod nvidia_uvmsudo rmmod nvidia</code></pre><p>在这个过程中可能会出现 <code>rmmod: ERROR: Module nvidia is in use</code> 的情况，说明有进程在使用驱动模块，我们需要终止这些进程。</p><pre><code>sudo lsof /dev/nvidia*</code></pre><p>然后一一 <code>kill</code> 掉，通过 <code>lsmod | grep nvidia</code> 来确定是否成功的 unload。之后通过 <code>nvidia-smi</code> 检查正确的驱动版本是否能被加载，若可以，则安装成功。</p><h2 id="安装-tenseofow">安装 Tenseofow</h2><p>直接使用 <code>pip</code> 进项安装，若速度较慢则可以尝试更换镜像源。安装之前记得删除旧的 TensorFlow</p><pre><code># pip install tensorflow-gpu==1.13.1</code></pre><p>打开ipython等</p><pre><code>import tensroflow as tfsess = tf.Session()</code></pre><p>若正确输出显卡信息则安装成功。</p>]]></content>
      
      
      <categories>
          
          <category> Technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Technique </tag>
            
            <tag> Environment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 347. Top K Frequent Elements</title>
      <link href="/2018/07/10/leetcode347-TopKFrequentElements/"/>
      <url>/2018/07/10/leetcode347-TopKFrequentElements/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><strong>问题描述</strong></h2><p>Given a non-empty array of integers, return the k most frequent elements.</p><p>Example 1:</p><pre><code>Input: nums = [1,1,1,2,2,3], k = 2Output: [1,2]</code></pre><p>Example 2:</p><pre><code>Input: nums = [1], k = 1Output: [1]</code></pre><p>Note:</p><ul><li>You may assume k is always valid, 1 ≤ k ≤ number of unique elements.</li><li>Your algorithm's time complexity must be better than O(n log n), where n is the array's size.</li></ul><h2 id="解题思路"><strong>解题思路</strong></h2><p>统计每个元素出现的次数。按次数排序取前k个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        d = collections.Counter(nums)</span><br><span class="line">        <span class="keyword">return</span> sorted(d.keys(), key=<span class="keyword">lambda</span> x:d[x], reverse=<span class="keyword">True</span>)[:k]</span><br></pre></td></tr></table></figure><h2 id="进阶"><strong>进阶</strong></h2><p>使用堆取前k大的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        l = [(-counts, elem) <span class="keyword">for</span> elem, counts <span class="keyword">in</span> collections.Counter(nums).items()]</span><br><span class="line">        heapq.heapify(l)</span><br><span class="line">        <span class="keyword">return</span> [heapq.heappop(l)[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(k)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> Heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode题之回溯法</title>
      <link href="/2018/07/02/Leetcode-BackTrace/"/>
      <url>/2018/07/02/Leetcode-BackTrace/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-关于回溯法">前言-关于回溯法</h2><h3 id="什么是回溯法">什么是回溯法</h3><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p><p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p><p>许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。但是同时回溯法也容易遇到递归次数过多的问题影响时间复杂度，这时候就要开始考虑进行减支或者尝试DP算法。</p><h3 id="基本思想">基本思想</h3><p>在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p><p>若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</p><p>而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p><h3 id="一般步骤">一般步骤</h3><pre><code>（1）针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。（2）确定结点的扩展搜索规则。（3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</code></pre><h3 id="算法框架">算法框架</h3><ol style="list-style-type: decimal"><li>问题框架</li></ol><p>设问题的解是一个n维向量 <span class="math inline">\((a_1,a_2,………,a_n)\)</span>，约束条件是 <span class="math inline">\(a_i(i=1,2,3,…..,n)\)</span> 之间满足某种条件，记为<span class="math inline">\(f(a_i)\)</span>。</p><ol start="2" style="list-style-type: decimal"><li><p>非递归回溯框架</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[n],i;</span><br><span class="line">初始化数组a[];</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i&gt;<span class="number">0</span>(有路可走)   <span class="keyword">and</span>  (未达到目标))&#123;  <span class="comment">// 还未回溯到头</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; n)&#123;    <span class="comment">// 搜索到叶结点</span></span><br><span class="line">        搜索到一个解，输出；</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 处理第i个元素</span></span><br><span class="line">        a[i]第一个可能的值；</span><br><span class="line">        <span class="keyword">while</span>(a[i]在不满足约束条件且在搜索空间内)&#123;</span><br><span class="line">            a[i]下一个可能的值；</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i]在搜索空间内)&#123;</span><br><span class="line">            标识占用的资源；</span><br><span class="line">            i = i+<span class="number">1</span>;  <span class="comment">// 扩展下一个结点</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            清理所占的状态空间； <span class="comment">// 回溯</span></span><br><span class="line">            i = i – <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>递归回溯框架</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[n];</span><br><span class="line"><span class="keyword">try</span>(<span class="keyword">int</span> i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;n)</span><br><span class="line">        输出结果;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = 下界; j &lt;= 上界; j=j+<span class="number">1</span>)&#123;  <span class="comment">// 枚举i所有可能的路径</span></span><br><span class="line">            <span class="keyword">if</span>(fun(j))&#123;                 <span class="comment">// 满足限界函数和约束条件</span></span><br><span class="line">                a[i] = j;</span><br><span class="line">                ...                         <span class="comment">// 其他操作</span></span><br><span class="line">                <span class="keyword">try</span>(i+<span class="number">1</span>);</span><br><span class="line">                回溯前的清理工作（如a[i]置空值等）;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="leetcode-17.-letter-combinations-of-a-phone-number">Leetcode 17. Letter Combinations of a Phone Number</h2><h3 id="题目描述-for-17">题目描述 for 17</h3><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><div class="figure"><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1933922589,3540416166&amp;fm=26&amp;gp=0.jpg" alt="phone number"><p class="caption">phone number</p></div><p>Example:</p><pre><code>Input: &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].Note:</code></pre><p>Although the above answer is in lexicographical order, your answer could be in any order you want.</p><h3 id="解题思路-遍历">解题思路-遍历</h3><p>遍历每一个数字代表的不同字母，找出所有组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        d = &#123;<span class="string">'2'</span>:[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>],</span><br><span class="line">            <span class="string">'3'</span>:[<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>],</span><br><span class="line">            <span class="string">'4'</span>:[<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>],</span><br><span class="line">            <span class="string">'5'</span>:[<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>],</span><br><span class="line">            <span class="string">'6'</span>:[<span class="string">'m'</span>,<span class="string">'n'</span>,<span class="string">'o'</span>],</span><br><span class="line">            <span class="string">'7'</span>:[<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'r'</span>,<span class="string">'s'</span>],</span><br><span class="line">            <span class="string">'8'</span>:[<span class="string">'t'</span>,<span class="string">'u'</span>,<span class="string">'v'</span>],</span><br><span class="line">            <span class="string">'9'</span>:[<span class="string">'w'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>]&#125;</span><br><span class="line">        result = d[digits[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> digits[<span class="number">1</span>:]:</span><br><span class="line">            al = d[s]</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> result:</span><br><span class="line">                <span class="keyword">for</span> a <span class="keyword">in</span> al:</span><br><span class="line">                    temp.append(r+a)</span><br><span class="line">            result = temp</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="leetcode-22.-generate-parentheses">Leetcode 22. Generate Parentheses</h2><h3 id="问题描述-for-22">问题描述 for 22</h3><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given n = 3, a solution set is:</p><pre><code>[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</code></pre><h3 id="解题思路-bt">解题思路-BT</h3><p>递归的找到所有合理解，通过一个变量 <code>state</code> 验证当前序列是否合法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        result = []</span><br><span class="line">        self.gen(result, n, <span class="string">""</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">(self, res, n, s, state)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">2</span>*n:</span><br><span class="line">            <span class="keyword">if</span> state == <span class="number">0</span>:</span><br><span class="line">                res.append(s)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 如果 state 小于0则代表当前右括号比左括号多</span></span><br><span class="line">        <span class="keyword">if</span> state &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.gen(res, n, s+<span class="string">"("</span>, state+<span class="number">1</span>)</span><br><span class="line">        self.gen(res, n, s+<span class="string">")"</span>, state<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h2 id="leetcode-46.-permutations">Leetcode 46. Permutations</h2><h3 id="题目描述-for-46">题目描述 for 46</h3><p>Given a collection of distinct integers, return all possible permutations.</p><p>Example:</p><pre><code>Input: [1,2,3]Output:[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><h3 id="解题思路-递归">解题思路-递归</h3><p>通过递归的方式遍历所有可能的结果。对每个不在 <code>temp</code> 中的元素，现考虑它在此位置的情况，再pop，考虑其他元素在此处的地方。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        result = []</span><br><span class="line">        self.trace(result, [], nums)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(self, result, temp, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(temp) == len(nums):</span><br><span class="line">            result.append(temp.copy())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">not</span> <span class="keyword">in</span> temp:</span><br><span class="line">                    temp.append(nums[i])</span><br><span class="line">                    self.trace(result, temp, nums)</span><br><span class="line">                    temp.pop(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h2 id="leetcode-78.-subsets">Leetcode 78. Subsets</h2><h3 id="题目描述-for-78">题目描述 for 78</h3><p>Given a set of distinct integers, nums, return all possible subsets (the power set).</p><p>Note: The solution set must not contain duplicate subsets.</p><p>Example:</p><pre><code>Input: nums = [1,2,3]Output:[[3],[1],[2],[1,2,3],[1,3],[2,3],[1,2],[]]</code></pre><h3 id="解题思路-还是递归">解题思路-还是递归</h3><p>使用递归的方式，对每种组合进行考虑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(result, temp, nums, i)</span>:</span></span><br><span class="line">            result.append(temp)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(i, len(nums)):</span><br><span class="line">                trace(result, temp+[nums[i]], nums, i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        trace(result, [], nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="leetcode-79.-word-search">Leetcode 79. Word Search</h2><h3 id="问题描述-for-79">问题描述 for 79</h3><p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where &quot;adjacent&quot; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p>Example:</p><pre><code>board =[[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],[&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],[&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false.</code></pre><h3 id="解题思路-从每个点进行递归">解题思路-从每个点进行递归</h3><p>从每个点开始递归遍历，如果找到正确答案则返回，否则继续。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(board, x, y, word, i)</span>:</span></span><br><span class="line">            <span class="comment"># x, y 代表当前所在单元，i表示已经找到的字长</span></span><br><span class="line">            <span class="keyword">if</span> i == len(word):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="comment"># 越界检查，以及当前单元代表字符跟word里相应位置的是否一致</span></span><br><span class="line">            <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> x == len(board) <span class="keyword">or</span> y == len(board[<span class="number">0</span>]) <span class="keyword">or</span> board[x][y] != word[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="comment"># 对目前所在的单元进行已读标记</span></span><br><span class="line">            tmp = board[x][y]</span><br><span class="line">            board[x][y] = <span class="string">"#"</span></span><br><span class="line">            <span class="comment"># 单元格的四个方向查找</span></span><br><span class="line">            exists = find(board, x+<span class="number">1</span>, y, word, i+<span class="number">1</span>) \</span><br><span class="line">                <span class="keyword">or</span> find(board, x, y+<span class="number">1</span>, word, i+<span class="number">1</span>) \</span><br><span class="line">                <span class="keyword">or</span> find(board, x<span class="number">-1</span>, y, word, i+<span class="number">1</span>) \</span><br><span class="line">                <span class="keyword">or</span> find(board, x, y<span class="number">-1</span>, word, i+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 恢复board的已读标记</span></span><br><span class="line">            board[x][y] = tmp</span><br><span class="line">            <span class="keyword">return</span> exists</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        h = len(board)</span><br><span class="line">        w = len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> find(board, i, j, word, <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><ul><li><a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741376.html" target="_blank" rel="noopener">五大常用算法之四：回溯法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Back Trace </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 240. Search a 2D Matrix II</title>
      <link href="/2018/06/24/leetcode240/"/>
      <url>/2018/06/24/leetcode240/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><strong>问题描述</strong></h2><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted in ascending from left to right.</li><li>Integers in each column are sorted in ascending from top to bottom. Example:</li></ul><p>Consider the following matrix:</p><pre><code>[    [1,   4,  7, 11, 15],    [2,   5,  8, 12, 19],    [3,   6,  9, 16, 22],    [10, 13, 14, 17, 24],    [18, 21, 23, 26, 30]]</code></pre><p>Given <code>target</code> = 5, return <code>true</code>.</p><p>Given <code>target</code> = 20, return <code>false</code>.</p><h2 id="解题思路"><strong>解题思路</strong></h2><p>先找到 <code>target</code> 可能在的行，然后在行内使用二分查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">            l = <span class="number">0</span></span><br><span class="line">            r = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r):</span><br><span class="line">                m = (l + r) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[m] == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">elif</span> nums[m] &lt; target:</span><br><span class="line">                    l = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(matrix)</span><br><span class="line">        <span class="keyword">for</span> nums <span class="keyword">in</span> matrix:</span><br><span class="line">            <span class="keyword">if</span> nums[<span class="number">0</span>] &gt; target:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> nums[<span class="number">-1</span>] &lt; target:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> binary_search(nums, target):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="进阶"><strong>进阶</strong></h2><p>对整个矩阵进行二分查找，或者进行分块儿查找。首先看整个矩阵 <code>((0, 0), (m-1, n-1))</code>，中点 <code>((m-1)//2, (n-1)//2)</code> 通过对比中点数据大小和target大小，确定target在哪个区域。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        X = [(<span class="number">0</span>, <span class="number">0</span>, m - <span class="number">1</span>, n - <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">while</span> X:</span><br><span class="line">            i, j, k, l = X.pop()</span><br><span class="line">            <span class="keyword">if</span> i &gt; k <span class="keyword">or</span> j &gt; l <span class="keyword">or</span> \</span><br><span class="line">                matrix[i][j] &gt; target <span class="keyword">or</span> matrix[k][l] &lt; target:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            p, q = (i + k)// <span class="number">2</span>, (j + l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[p][q] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> matrix[p][q] &lt; target:</span><br><span class="line">                X += [(p + <span class="number">1</span>, j, k, q), (<span class="number">0</span>, q + <span class="number">1</span>, k, l)]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                X += [(i, j, k, q - <span class="number">1</span>), (<span class="number">0</span>, q, p - <span class="number">1</span>, l)]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="python耍赖做法"><strong>Python耍赖做法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> any(target <span class="keyword">in</span> row <span class="keyword">for</span> row <span class="keyword">in</span> matrix)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 215. Kth Largest Element in an Array</title>
      <link href="/2018/06/22/leetcode215-KthLargestElementInAnArray/"/>
      <url>/2018/06/22/leetcode215-KthLargestElementInAnArray/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><strong>问题描述</strong></h2><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><p>Example 1:</p><pre><code>Input: [3,2,1,5,6,4] and k = 2Output: 5</code></pre><p>Example 2:</p><pre><code>Input: [3,2,3,1,2,4,5,5,6] and k = 4Output: 4</code></pre><p>Note:</p><ul><li>You may assume k is always valid, 1 ≤ k ≤ array's length.</li></ul><h2 id="解题思路"><strong>解题思路</strong></h2><p>堆排序，建堆O(logn)，取前k个，总时间复杂度O(klogn)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        <span class="keyword">return</span> heapq.nlargest(k, nums)[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="进阶"><strong>进阶</strong></h2><p>快排方法，将比pivot小的移动到pivot左边大的移动到右边，如果结束后pivot位于第k个则pivot即为答案。如果大于k则从pivot左边找，小于则从右边找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.partition( <span class="number">0</span>, len(nums) - <span class="number">1</span>, nums, len(nums) - k)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, l, r, nums, k)</span>:</span></span><br><span class="line"></span><br><span class="line">        pivoti = random.randint(l, r)</span><br><span class="line">        pivot = nums[pivoti]</span><br><span class="line">        nums[pivoti], nums[r] = nums[r], nums[pivoti]</span><br><span class="line"></span><br><span class="line">        L = l</span><br><span class="line">        R = r - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> L &lt;= R:</span><br><span class="line">            <span class="keyword">while</span> nums[L] &lt; pivot:</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> nums[R] &gt; pivot:</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> L &lt;= R:</span><br><span class="line">                nums[L], nums[R] = nums[R], nums[L]</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        nums[L], nums[r] = nums[r], nums[L]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> L == k:</span><br><span class="line">            <span class="keyword">return</span> nums[L]</span><br><span class="line">        <span class="keyword">elif</span> L &gt; k:</span><br><span class="line">            <span class="keyword">return</span> self.partition(l, L - <span class="number">1</span>, nums, k)</span><br><span class="line">        <span class="keyword">elif</span> L &lt; k:</span><br><span class="line">            <span class="keyword">return</span> self.partition(L + <span class="number">1</span>, r,  nums, k)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> Heap </tag>
            
            <tag> Quick Sort </tag>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 79.Word Search</title>
      <link href="/2018/06/19/leetcode79-WordSearch/"/>
      <url>/2018/06/19/leetcode79-WordSearch/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><strong>问题描述</strong></h2><p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where &quot;adjacent&quot; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p>Example:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>],</span><br><span class="line">  [<span class="string">'S'</span>,<span class="string">'F'</span>,<span class="string">'C'</span>,<span class="string">'S'</span>],</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word = <span class="string">"ABCCED"</span>, <span class="keyword">return</span> true.</span><br><span class="line">Given word = <span class="string">"SEE"</span>, <span class="keyword">return</span> true.</span><br><span class="line">Given word = <span class="string">"ABCB"</span>, <span class="keyword">return</span> false.</span><br></pre></td></tr></table></figure><h2 id="解题思路"><strong>解题思路</strong></h2><p>回朔法，从board中每个元素出发遍历周围的四个元素，查看是否能组成部分答案，若能，则继续从该元素出发进行查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(board, x, y, word, i)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i == len(word):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> x == len(board) <span class="keyword">or</span> y == len(board[<span class="number">0</span>]) <span class="keyword">or</span> board[x][y] != word[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            tmp = board[x][y]</span><br><span class="line">            board[x][y] = <span class="string">"#"</span></span><br><span class="line">            exists = find(board, x+<span class="number">1</span>, y, word, i+<span class="number">1</span>) \</span><br><span class="line">                <span class="keyword">or</span> find(board, x, y+<span class="number">1</span>, word, i+<span class="number">1</span>) \</span><br><span class="line">                <span class="keyword">or</span> find(board, x<span class="number">-1</span>, y, word, i+<span class="number">1</span>) \</span><br><span class="line">                <span class="keyword">or</span> find(board, x, y<span class="number">-1</span>, word, i+<span class="number">1</span>)</span><br><span class="line">            board[x][y] = tmp</span><br><span class="line">            <span class="keyword">return</span> exists</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        h = len(board)</span><br><span class="line">        w = len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> find(board, i, j, word, <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Back Trace </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 162. Find Peak Element</title>
      <link href="/2018/06/13/leetcode162-FindPeakElements/"/>
      <url>/2018/06/13/leetcode162-FindPeakElements/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><strong>问题描述</strong></h2><p>A peak element is an element that is greater than its neighbors.</p><p>Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.</p><p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p><p>You may imagine that nums[-1] = nums[n] = -∞.</p><p>Example 1:</p><pre><code>Input: nums = [1,2,3,1]Output: 2Explanation: 3 is a peak element and your function should return the index number 2.</code></pre><p>Example 2:</p><pre><code>Input: nums = [1,2,1,3,5,6,4]Output: 1 or 5Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</code></pre><p>Note:</p><p>Your solution should be in logarithmic complexity.</p><h2 id="解决思路"><strong>解决思路</strong></h2><p>因为题目要求对数复杂度，而且是一个查找问题，直觉使用二分查找。与二分查找的不同在于对high重新赋值为mid而不是mid-1，因为我们希望mid在 <code>nums[mid] &gt; nums[mid+1]</code> 的同时再比较一次 <code>nums[mid-1] 和 nums[mid]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums: <span class="string">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        low, high = <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            mid = (low+high)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[mid+<span class="number">1</span>]:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid</span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux挂载硬盘</title>
      <link href="/2018/06/10/Linux%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/"/>
      <url>/2018/06/10/Linux%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h1 id="linux-挂载多块大容量硬盘">Linux 挂载多块大容量硬盘</h1><h2 id="前言">前言</h2><p>最近实验室采购了十台服务器，每台服务器配备了4块4T机械硬盘，本文记录了硬盘的挂载过程，以及虚拟存储工具 mhddfs 的使用。</p><p>4块机械硬盘分别为 /dev/sda, /dev/sdb, /dev/sdc, /dev/sdd.</p><h2 id="步骤">步骤</h2><ul><li>查看硬盘信息</li><li>查看挂载信息</li><li>分区命令</li><li>格式化分区</li><li>开机自动挂载</li><li>多硬盘合并挂载 mhddfs</li></ul><h2 id="查看硬盘信息">查看硬盘信息</h2><p>可以使用 <code>fdisk</code> 命令，fdisk 命令可以观察硬盘实体使用情况。</p><pre><code>$ sudo fdisk -lh</code></pre><p>通过命令可以看到目前系统中有哪些硬盘，以及它们各自的分区。</p><h2 id="查看挂载信息">查看挂载信息</h2><p>通过 <code>df</code> 命令可以查看硬盘的挂载信息。</p><pre><code>$ df -lhFilesystem                   Size  Used Avail Use% Mounted onudev                          32G     0   32G   0% /devtmpfs                        6.3G   18M  6.3G   1% /run/dev/mapper/ubuntu--vg-root  869G   63G  763G   8% /tmpfs                         32G     0   32G   0% /dev/shmtmpfs                        5.0M  4.0K  5.0M   1% /run/locktmpfs                         32G     0   32G   0% /sys/fs/cgroup/dev/nvme0n1p2               473M  149M  301M  34% /boot/dev/nvme0n1p1               511M  3.6M  508M   1% /boot/efitmpfs                        6.3G     0  6.3G   0% /run/user/1000</code></pre><p>可以看到目前系统中仅挂载了一块固态硬盘。</p><h2 id="分区命令">分区命令</h2><p><code>fdisk</code> 命令不仅可以用于观察硬盘实体使用情况，也可以对硬盘进行分区。但 <code>fdisk</code> 命令进行分区最多仅支持2T容量。所以对于4T硬盘，可以使用 <code>parted</code> 命令进行分区。</p><p><code>parted</code> 命令是由GNU组织开发的一款功能强大的磁盘分区和分区大小调整工具，与 <code>fdisk</code> 不同，它支持调整分区的大小。作为一种设计用于Linux的工具，它没有构建成处理与 <code>fdisk</code> 关联的多种分区类型，但是，它可以处理最常见的分区格式，包括：ext2、ext3、fat16、fat32、NTFS、ReiserFS、JFS、XFS、UFS、HFS以及Linux交换分区。</p><pre><code>$ sudo parted /dev/sdaGNU Parted 3.2Using /dev/sdaWelcome to GNU Parted! Type &#39;help&#39; to view a list of commands.(parted) mklabel gpt(parted) unit TB(parted) mkpart primary 0 4(parted) pGNU Parted 3.2Using /dev/sdaWelcome to GNU Parted! Type &#39;help&#39; to view a list of commands.Model: ATA ST4000NM0035-1V4 (scsi)Disk /dev/sda: 4001GBSector size (logical/physical): 512B/512BPartition Table: gptDisk Flags:Number  Start   End     Size    File system  Name     Flags1      1049kB  4001GB  4001GB               primary</code></pre><h2 id="格式化分区">格式化分区</h2><p>使用 <code>mkfs</code> 命令，将创建好的分区格式化为 ext4 格式。</p><pre><code>$ sudo mkfs.ext4 /dev/sda1</code></pre><h2 id="开机自动挂载">开机自动挂载</h2><p>通过 <code>blkid</code> 命令查看硬盘UUID</p><pre><code>$ sudo blkid/dev/nvme0n1p1: UUID=&quot;6062-5002&quot; TYPE=&quot;vfat&quot; PARTUUID=&quot;23340a62-728f-4a13-855d-12783a6745d9&quot;/dev/nvme0n1p2: UUID=&quot;058309c1-a4f4-42d4-a011-9c59f331d327&quot; TYPE=&quot;ext2&quot; PARTUUID=&quot;c3b8246a-4753-414d-be15-1dd85840a949&quot;/dev/nvme0n1p3: UUID=&quot;wr77H2-n6Qt-BKuF-4IdY-IE2S-4fFk-Du7c06&quot; TYPE=&quot;LVM2_member&quot; PARTUUID=&quot;4f0227e4-d948-4dee-9e54-ba022051073b&quot;/dev/mapper/ubuntu--vg-root: UUID=&quot;5fb8ed79-a83b-4d34-a6d3-d554dfeb3d2e&quot; TYPE=&quot;ext4&quot;/dev/sda1: UUID=&quot;a520f550-1807-475d-8737-72733444d48f&quot; TYPE=&quot;ext4&quot; PARTLABEL=&quot;primary&quot; PARTUUID=&quot;94dbf9bb-924d-40a5-99b1-a1116801aeaa&quot;/dev/sdb1: UUID=&quot;085423aa-4578-4dda-a7d5-5c6b85feadb2&quot; TYPE=&quot;ext4&quot; PARTLABEL=&quot;primary&quot; PARTUUID=&quot;47eee203-601d-48d4-937c-ff45a9a17222&quot;/dev/sdc1: UUID=&quot;ade474c4-e8b2-4cc6-804d-802a283f164d&quot; TYPE=&quot;ext4&quot; PARTLABEL=&quot;primary&quot; PARTUUID=&quot;2885a317-a2b4-4d0c-aebb-97c6fb8c56e3&quot;/dev/sdd1: UUID=&quot;ce9dda21-86ac-4c6b-aac3-5d464d348e52&quot; TYPE=&quot;ext4&quot; PARTLABEL=&quot;primary&quot; PARTUUID=&quot;f48c33d8-3170-4802-bab5-ee1e0add763c&quot;/dev/mapper/ubuntu--vg-swap_1: UUID=&quot;4f617909-ed55-45ba-85ce-b1d211b44fca&quot; TYPE=&quot;swap&quot;/dev/nvme0n1: PTUUID=&quot;2fff60a6-1c9d-43f2-9b4f-182dced404e2&quot; PTTYPE=&quot;gpt&quot;</code></pre><p>修改 /etc/fstab 文件，加入表项</p><pre><code>UUID= /mnt/A ext4 defaults 0 2</code></pre><p>将挂载硬盘的UUID填入。在相应位置创建挂载点（/mnt/A）并修改权限。 使用命令 <code>mount</code> 挂载硬盘</p><pre><code>$ sudo mount /dev/sda1</code></pre><h2 id="多硬盘合并挂载-mhddfs">多硬盘合并挂载 <code>mhddfs</code></h2><p>现在已经将4块硬盘都挂载在了相应的文件夹下 (/mnt/A /mnt/B /mnt/C /mnt/D) 但是由于过多的挂载点导致文件分散在不同的目录下，对于访问文件十分不利。所以可以使用 <code>mhddfs</code> 将多个硬盘挂载在一个路径下。也称作 Linux 分区合并，即 Linux 挂载点合并。</p><p><code>mhddfs</code> 是一个 FUSE 系统模块，它可以将多个 Linux 分区(挂载点)或硬盘组合成一个虚拟驱动器。这样我们就可以将文件丢到 <code>mhddfs</code> 创建的虚拟驱动器中，它会自动将文件分布到不同的挂载点中，而用户看起来就像是放到了一个统一的路径。</p><p><code>mhddfs</code> 安装</p><pre><code>$ sudo apt install mhddfs</code></pre><p>创建挂载点并修改权限后，使用命令</p><pre><code>$ sudo mhddfs /mnt/A,/mnt/B,/mnt/C,/mnt/D /extend -o allow_other</code></pre><p>在 /etc/fstab 中写入</p><pre><code>mhddfs#/mnt/A,/mnt/B,/mnt/C,/mnt/D /extend fuse defaults,allow_other 0 0</code></pre><p>以实现开机自动挂载</p>]]></content>
      
      
      <categories>
          
          <category> Technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Hard Drive </tag>
            
            <tag> Mount </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Samba共享文件</title>
      <link href="/2018/06/05/Samba/"/>
      <url>/2018/06/05/Samba/</url>
      
        <content type="html"><![CDATA[<h1 id="使用samba共享文件">使用samba共享文件</h1><h2 id="前言">前言</h2><p>最近因为很多原因需要共享一个 Ubuntu 系统下的文件夹供他人访问，于是决定使用 samba 。</p><h2 id="关于samba">关于samba</h2><p>Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。SMB协议是客户机/服务器型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。通过设置“NetBIOS over TCP/IP”使得Samba不但能与局域网络主机分享资源，还能与全世界的电脑分享资源。</p><p>SMB（Server Message Block）通信协议是微软（Microsoft）和英特尔(Intel)在1987年制定的协议，主要是作为Microsoft网络的通讯协议。SMB 是在会话层（session layer）和表示层（presentation layer）以及小部分应用层（application layer）的协议。 SMB使用了NetBIOS的应用程序接口 （Application Program Interface，简称API）。另外，它是一个开放性的协议，允许了协议扩展——使得它变得更大而且复杂；大约有65个最上层的作业，而每个作业都超过120个函数，甚至Windows NT也没有全部支持到，最近微软又把 SMB 改名为 CIFS（Common Internet File System），并且加入了许多新的特色。</p><h2 id="环境">环境</h2><pre><code>Ubuntu 16.044.13.0-43-generic</code></pre><h2 id="samba-安装">Samba 安装</h2><pre><code>$ sudo apt install samba</code></pre><h2 id="samba-配置">Samba 配置</h2><p>Samba 服务的配置文件位于 /etc/samba/smb.conf</p><h4 id="全局文件配置参数">全局文件配置参数</h4><pre><code>[global]    config file = /etc/samba/smb.conf.%U       #可以让你使用另一个配置文件来覆盖缺省的配置文件。如果文件 不存在，则该项无效。    workgroup = WORKGROUP                      #工作组名称    server string = Samba Server Version %v    #主机的简易说明    netbios name = MYSERVER                    #主机的netBIOS名称，如果不填写则默认服务器DNS的一部分，workgroup和netbios name名字不要设置成一样    interfaces = lo eth0 192.168.12.2/24 192.168.13.2/24                                                  #设置samba服务器监听网卡，可以写网卡名称或IP地址，默认注释    hosts allow = 127. 192.168.12. 192.168.13. #设置允许连接到samba服务器的客户端，默认注释    hosts deny = 192.168.12.0/255.255.255.0    #设置不允许连接到samba服务器的客户端，默认注释    log level = 1                              #日志文件安全级别，0~10级别，默认0    log file = /var/log/samba/%m               #产生日志文件的命名，默认以访问者IP地址命名    max log size = 50                          #日志文件最大容量50，默认50，单位为KB，0表示不限制</code></pre><h4 id="自定义共享文件配置参数">自定义共享文件配置参数</h4><pre><code>[share]                                        # 自定义共享名    comment = Home Directories                 # 描述符，是给系统管理员看的    path = /tmp                                # 共享的路径    public = yes                               # 是否公开，也就是是否能在网上邻居看到该共享    browseable = yes                           # 共享的目录是否让所有人可见    writable = yes                             # 是否可写    guest ok = no                              # 是否拒绝匿名访问，仅当安全级别为 share 时才生效    workgroup = WORKGROUP                      # 工作组，要设置成跟 Windows 的工作组一致    server string = Samba Server Version %v    # 其他 Linux 主机查看共享时的提示符    netbios name = MYSERVER                    # 用于在 Windows 网上邻居上显示的主机名    hosts allow = 127. 192.168.12. 192.168.13. EXCEPT 192.168.13.13   # 指定允许访问 samba 服务器的主机    security = share                           # 定义安全级别    log file = /var/log/samba/log.%m           # 定义日志文件，每个访问的主机会产生独立的日志文件，%m 是客户端主机名    max log size = 50                          # 定义单个日志的最大容量（KB）    passdb backend = tdbsam                    # Samba 用户的存储方式，smbpasswd 表示明文存储，tdbsam 表示密文存储    deadtime = 10                              # 客户端在10分钟内没有打开任何 Samba 资源，服务器将自动关闭会话。    display charset = UTF8                     # 设置显示的字符集    max connections = 0                        # 设置最大连接数，0表示无限制，如果超过最大连接数则拒绝连接    guest account = nobody                     # 设置匿名账户为nobody    load printers = yes                        # 是否在启动 Samba 时就共享打印机    cups options = raw                         # 设置打印机使用的方式    valid users = user1 user2 user3            # 指定哪些用户可以访问，如果不指定则所有用户都可访问    invalid users = user1 user2                # 指定哪些用户不可以访问    create mask = 0775                         # 客户端上传文件的默认权限    directory mask = 0775                      # 客户端创建目录的默认权限    write list = user1 user2 user3             # 设置可对文件进行写操作的用户    admin users = user1                        # 设置共享目录的管理员，具有完全权限    force create mode = 0775                   # Windows 与 Linux 具有不同的文件和文件夹默认权限，Windows下新建的文件是    force directory mode = 0775                # 可执行的，所以必须强制设定其权限</code></pre><h4 id="关于安全级别">关于安全级别</h4><pre><code>share ：表示匿名用户，不需要 samba 账户就可登陆 samba 服务器user ：系统账户要先添加进 samba 库然后变成 samba 用户，使用 samba 用户来登陆，简单来讲就是需要使用用户密码登录server ：由另外一台 samba 服务器来对用户进行身份验证domain ：把 samba 服务器加入到 NT 域，由 NT 的域控制器来进行身份验证ADS ：（Active Directory Service，活动目录服务），是 samba3.0 中新增的身份验证方式，采用 ADS 验证方式，samba 服务器集成到活动目录中</code></pre><h4 id="实用的配置">实用的配置</h4><p>可以用此配置共享一个服务器上的所有文件，使浏览数据更加方便。<em>但这样做会产生一定的安全风险。</em></p><pre><code>[share]    path = /    public = yes    writable = yes    valid users = user    create mask = 0775    force create mode = 0775    directory mask = 0775    force directory mode = 0775    available = yes</code></pre><h4 id="设置登录密码">设置登录密码</h4><pre><code>$ sudo touch /etc/samba/smbpasswd               $ sudo smbpasswd -a                             # 根据设置的valid user，设置用户密码。</code></pre><h4 id="重启-samba-服务使配置生效">重启 Samba 服务使配置生效</h4><pre><code>$ sudo /etc/init.d/samba restart</code></pre><h4 id="通过-windows-连接">通过 Windows 连接</h4><p>在文件资源管理器输入</p><pre><code>\\(ip)</code></pre><h4 id="通过-linux-连接">通过 Linux 连接</h4><p>在 connect to server，输入</p><pre><code>smb://(ip)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> share </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 75. Sort Colors</title>
      <link href="/2018/05/28/leetcode75-SortColor/"/>
      <url>/2018/05/28/leetcode75-SortColor/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><strong>问题描述</strong></h2><p>Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p><p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p><p>Note: You are not suppose to use the library's sort function for this problem.</p><p>Example:</p><pre><code>Input: [2,0,2,1,1,0]Output: [0,0,1,1,2,2]</code></pre><p>Follow up:</p><ul><li>A rather straight forward solution is a two-pass algorithm using counting sort.</li><li>First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with a one-pass algorithm using only constant space?</li></ul><h2 id="解题思路"><strong>解题思路</strong></h2><p>基本按照计数排序的思路，先遍历统计0、1、2的个数。根据个数重新对数组赋值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            count[i] += <span class="number">1</span></span><br><span class="line">        print(count)</span><br><span class="line">        print(nums[:count[i]])</span><br><span class="line">        nums[:count[<span class="number">0</span>]] = [<span class="number">0</span>]*count[<span class="number">0</span>]</span><br><span class="line">        nums[count[<span class="number">0</span>]:count[<span class="number">1</span>]+count[<span class="number">0</span>]] = [<span class="number">1</span>]*count[<span class="number">1</span>]</span><br><span class="line">        nums[count[<span class="number">1</span>]+count[<span class="number">0</span>]:] = [<span class="number">2</span>]*count[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h2 id="进阶思路"><strong>进阶思路</strong></h2><p>上述做法貌似需要 <span class="math inline">\(O(n)\)</span> 的额外存储空间，如果 <span class="math inline">\(O(1)\)</span> 来做又会导致遍历两次。因此可以考虑类似快速排序的做法，两个指针分别指向头尾，一个指针从左到右移动。。将遇到的2移动到最右边，遇到的0移动到最左边。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums: <span class="string">'List[int]'</span>)</span> -&gt; '<span class="keyword">None</span>':</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;=r:</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">2</span> <span class="keyword">and</span> i&lt;r:</span><br><span class="line">                nums[i], nums[r] = nums[r], nums[i]</span><br><span class="line">                r-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == <span class="number">0</span> <span class="keyword">and</span> i&gt;l:</span><br><span class="line">                nums[i], nums[l] = nums[l], nums[i]</span><br><span class="line">                l+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 56. Merge Intervals</title>
      <link href="/2018/05/24/leetcode56/"/>
      <url>/2018/05/24/leetcode56/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><strong>题目描述</strong></h2><p>Given a collection of intervals, merge all overlapping intervals.</p><p>Example 1:</p><pre><code>Input: [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</code></pre><p>Example 2:</p><pre><code>Input: [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considered overlapping.</code></pre><h2 id="解题思路"><strong>解题思路</strong></h2><p>将所有的interval按开始时间排序，检测是否重叠，若重叠，检测结束时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> len(intervals) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> intervals</span><br><span class="line">        intervals = sorted(intervals)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">or</span> res[<span class="number">-1</span>][<span class="number">1</span>] &lt; i[<span class="number">0</span>]:</span><br><span class="line">                res.append(i)</span><br><span class="line">            <span class="keyword">elif</span> res[<span class="number">-1</span>][<span class="number">1</span>] &lt; i[<span class="number">1</span>]:</span><br><span class="line">                res[<span class="number">-1</span>][<span class="number">1</span>] = i[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 34. Find First and Last Position of Element in Sorted Array</title>
      <link href="/2018/05/23/leetcode34-FindFirstandLastPositionofElementInSortedArray/"/>
      <url>/2018/05/23/leetcode34-FindFirstandLastPositionofElementInSortedArray/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><strong>问题描述</strong></h2><p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</p><p>Your algorithm's runtime complexity must be in the order of <span class="math inline">\(O(log n)\)</span>.</p><p>If the target is not found in the array, return [-1, -1].</p><p>Example 1:</p><pre><code>Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4]</code></pre><p>Example 2:</p><pre><code>Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1]</code></pre><h2 id="解题思路"><strong>解题思路</strong></h2><p>对数时间复杂度，优先考虑二分查找，先找出目标数的左界。通常做法，二分查找对于右指针的更新改为mid而不是mid-1。然后查找target的右界，同样使用二分查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        n = len(nums)</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            m = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &lt; target:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 对于有界的更新进行改动，这样可以保证找到的m一定是target左界</span></span><br><span class="line">                r = m</span><br><span class="line">        <span class="keyword">if</span> nums[l] != target: <span class="keyword">return</span> <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">        left = l</span><br><span class="line">        l, r = left, n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            m = (l+r) // <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 对条件进行改动，使其找到的是第一个非target，即为右界</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == target:</span><br><span class="line">                l = m</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = m<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> left, l</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 33. Search in Rotated Sorted Array</title>
      <link href="/2018/05/23/leetcode33/"/>
      <url>/2018/05/23/leetcode33/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><strong>问题描述</strong></h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><p>(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</p><p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p><p>You may assume no duplicate exists in the array.</p><p>Your algorithm's runtime complexity must be in the order of O(log n).</p><p>Example 1:</p><pre><code>Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4</code></pre><p>Example 2:</p><pre><code>Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1</code></pre><h2 id="解题思路"><strong>解题思路</strong></h2><p>要求对数复杂度，首先考虑二分查找。先用二分查找找到最小值，然后再根据target所在区间进行二分查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            m = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &gt; nums[r]:</span><br><span class="line">                l = m+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = m</span><br><span class="line">        s = l</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[s] &lt;= target &lt;= nums[r]:</span><br><span class="line">            l = s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = s</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r):</span><br><span class="line">            m = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == target:</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">            <span class="keyword">elif</span> nums[m] &gt; target:</span><br><span class="line">                r = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="进阶"><strong>进阶</strong></h2><p>可以考虑只进行一次二分查找。通过比较mid和r确定pivot点的大概位置。如果m大于r，且 target 在l与m之间，重新在 (l, m-1) 查找，若不是，则在 (m+1, r) 之间查找。若m小于r，当 target 在m与r之间则在 (m+1, r) 内进行查找，否则在 (l, m-1) 内进行查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            m = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == target:</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">            <span class="keyword">elif</span> nums[m] &gt; nums[r]:</span><br><span class="line">                <span class="keyword">if</span> nums[l] &lt;= target &lt;= nums[m]:</span><br><span class="line">                    r = m - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[m] &lt;= target &lt;= nums[r]:</span><br><span class="line">                    l = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = m - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># Time: O(log(N))</span></span><br><span class="line">        <span class="comment"># Space: O(1)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Boosting算法族一 Adaboost</title>
      <link href="/2017/10/09/Boosting1/"/>
      <url>/2017/10/09/Boosting1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><strong>前言</strong></h2><p>Boosting 是一族可将弱学习器提升为强学习器的算法。这族算法的工作机制类似：先从初始训练集训练一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得先前基学习器做错的样本受到更多关注，然后基于调整过后的分布来训练下一个基学习器，如此反复进行，直到基学习器数目达到事先指定的值 <span class="math inline">\(T\)</span> ,最终将这 <span class="math inline">\(T\)</span> 个基学习器进行加权组合。</p><h2 id="加法模型和向前分布算法"><strong>加法模型和向前分布算法</strong></h2><p>Boosting算法族的基本特点是:</p><ul><li>1.加法模型</li><li>2.向前分步算法</li></ul><p>加法模型的意思是最终得到的模型，是若干个基函数的加和。</p><p><span class="math display">\[f(x) = \sum_{m=1}^{M}\beta_mb(x;\gamma_m)\]</span></p><p>其中，<span class="math inline">\(b(x;\gamma_m)\)</span> 称为基函数，<span class="math inline">\(\gamma_m\)</span> 为第 <span class="math inline">\(ｍ\)</span> 个基函数的参数，<span class="math inline">\(\beta_m\)</span> 为基函数的系数。</p><p>在给定训练数据和损失函数 <span class="math inline">\(L(y,f(x))\)</span> 的条件下学习加法模型 <span class="math inline">\(f(x)\)</span> 就成为风险极小化问题，即损失函数极小化问题</p><p><span class="math display">\[\min_{\beta_m,\gamma_m}\sum_{i=1}^{N}L(y_i, \sum_{m=1}^{M}\beta_mb(x_i;\gamma_m))\]</span></p><p>随后该问题可以简化为:　从前向后，每一步只学习一个基函数及其系数，逐渐逼近上式，即: 每步只优化如下损失函数:</p><p><span class="math display">\[ \min_{\beta, \gamma} \sum_{i=1}^{N}L(y_i, \beta b(x_i;\gamma))\]</span></p><hr><p>输入: <span class="math inline">\(T=\{\}\)</span><br>损失函数: <span class="math inline">\(L(y,f(x))\)</span><br>基函数集: <span class="math inline">\(\{b(x;\gamma)\}\)</span> 输出: 加法模型 <span class="math inline">\(f(x)\)</span><br>算法步骤:<br>  初始化 <span class="math inline">\(f_0(x)=0\)</span><br>  for <span class="math inline">\(m=1, 2, 3, ... ,M\)</span> do<br>    极小化损失函数 <span class="math inline">\(\arg\min_{\beta,\gamma}\sum_{i=1}^{N}L(y_i,f_{m-1}(x_i) + \beta b(x_i;\gamma))\)</span><br>    更新 <span class="math inline">\(f_m(x) = f_{m-1}(x) + \beta_m b(x;\gamma_m)\)</span><br>  end for<br>输出: 加法模型 <span class="math inline">\(f(x)=f_M(x)=\sum_{m=1}^{M}\beta_m b(x;\gamma_m)\)</span></p><hr><p>向前分布算法是加法模型的一个学习方法。</p><h2 id="adaboost"><strong>AdaBoost</strong></h2><h3 id="adaboost-算法"><strong>AdaBoost 算法</strong></h3><p>AdaBoost 是Boosting家族一个比较著名的代表。基本算法如下（其中 <span class="math inline">\(y_i \in \{-1, +1\}\)</span>，<span class="math inline">\(f\)</span> 是真实函数）:</p><hr><p><strong>输入:</strong> 训练集 <span class="math inline">\(D=\{({\boldsymbol x}_1,y_1),({\boldsymbol x}_2,y_2),...,({\boldsymbol x}_m,y_m)\}\)</span><br>    基学习算法 <span class="math inline">\(\mathfrak{L}\)</span><br>    训练轮数 <span class="math inline">\(T\)</span><br><strong>过程:</strong><br><span class="math inline">\(\mathcal{D}_1 = \frac{1}{m}\)</span><br>for <span class="math inline">\(t=1,2,...,T\)</span> do<br>   <span class="math inline">\(h_t=\mathfrak{L}(D, \mathcal{D}_t)\)</span><br>   <span class="math inline">\(\epsilon_t=P_{x\sim\mathcal{D}_t}(h_t({\boldsymbol x}) \neq f(\boldsymbol x))\)</span><br>   if <span class="math inline">\(\epsilon_t &gt; 0.5\)</span> then break<br>   <span class="math inline">\(\alpha_t=\frac{1}{2}ln(\frac{1-\epsilon_t}{\epsilon_t})\)</span><br>   <span class="math inline">\(\begin{aligned} \mathcal{D}_{t+1}({\boldsymbol x}) = \frac{\mathcal{D}_t({\boldsymbol x})}{Z_t} \times\begin{cases}  exp(-\alpha_t) \quad if h_t(\boldsymbol x) = f(\boldsymbol x)\\  exp(\alpha_t) \quad if h_t(\boldsymbol x) \neq f(\boldsymbol x) \end{cases}  = \frac{\mathcal{D}_t({\boldsymbol x})exp(-\alpha_t f({\boldsymbol x})h_t({\boldsymbol x}))}{Z_t} \end{aligned}\)</span><br>end for<br><strong>输出:</strong> <span class="math inline">\(H(\boldsymbol x)=sign(\sum_{t=1}^{T}\alpha_th_t({\boldsymbol x}))\)</span></p><hr><h3 id="adaboost-算法的推导"><strong>Adaboost 算法的推导</strong></h3><p>AdaBoost 训练学习器的线性组合 <span class="math display">\[    H(\boldsymbol{x})=\sum_{t=1}^{T}\alpha_th_t(\boldsymbol{x})    \tag{1}\]</span> 来最小化指数损失函数 (exponential loss function) <span class="math display">\[    \ell_{exp}(H|\mathcal{D})=\mathbb{E}_{x\sim\mathcal{D}}    [e^{-f(\boldsymbol{x})H(\boldsymbol{x})}]    \tag{2}\]</span> 若 <span class="math inline">\(H(\boldsymbol{x})\)</span> 能另指数损失函数最小化，则考虑式 <span class="math inline">\((2)\)</span> 对 <span class="math inline">\(H(\boldsymbol{x})\)</span> 的偏导 <span class="math display">\[    \frac{\partial\ell_{exp}(H|\mathcal{D})}{\partial H(\boldsymbol{x})}=-e^{-H(\boldsymbol{x})}P(f(\boldsymbol{x})=1|\boldsymbol{x})+e^{H(\boldsymbol{x})}P(f(\boldsymbol{x}) = -1 | \boldsymbol{x})    \tag{3}\]</span> 另式 <span class="math inline">\((3)\)</span> 为零可解得 <span class="math display">\[    H(\boldsymbol{x})=\frac{1}{2}ln\frac{P(f(\boldsymbol{x})=1|\boldsymbol{x})}{P(f(\boldsymbol{x}) = -1 | \boldsymbol{x})}    \tag{4}\]</span> 因此，有 <span class="math display">\[    \begin{aligned}        sign(H(\boldsymbol{x}))&amp;=sign(\frac{1}{2}ln\frac{P(f(\boldsymbol{x})=1|\boldsymbol{x})}{P(f(\boldsymbol{x}) = -1 | \boldsymbol{x})})\\        &amp;=            \begin{cases}                1 &amp;\quad P(f(\boldsymbol{x})=1|\boldsymbol{x}) &gt; P(f(\boldsymbol{x})=-1|\boldsymbol{x}) \\                -1 &amp;\quad P(f(\boldsymbol{x})=1|\boldsymbol{x}) &lt; P(f(\boldsymbol{x})=-1|\boldsymbol{x})            \end{cases} \\        &amp;= \arg\min_{\mathcal{y}\in\{-1.1\}}P(f({x})=y|\boldsymbol{x})    \end{aligned}    \tag{5}\]</span> 这意味着 <span class="math inline">\(sign(H(\boldsymbol{x}))\)</span> 达到了贝叶斯最优错误率。换言之，若指数函数最小化，则分类错误率也将最小化。这说明指数损失函数是分类任务原本 <span class="math inline">\(0/1\)</span> 损失函数的一致的 (consistent) 替代损失函数。该函数连续可微，数学性质更好，因此我们用它替代 <span class="math inline">\(0/1\)</span> 损失函数作为优化目标。</p><p>在AdaBoost算法中，关于 <span class="math inline">\(\alpha_t\)</span> ，<span class="math inline">\(h_t\)</span> 基于 <span class="math inline">\(\mathcal{D}_t\)</span> 产生后，该基分类器权重 <span class="math inline">\(\alpha_t\)</span> 应使 <span class="math inline">\(\alpha_th_t\)</span> 最小化损失函数。 <span class="math display">\[    \begin{aligned}        \ell_{exp}(\alpha_th_t|\mathcal{D}_t)&amp;=\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}_t}[e^{-f(\boldsymbol{x})\alpha_th_t(\mathcal{x})}] \\        &amp;=\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}_t}[e^{-\alpha_t}\mathbb{I}(f(\boldsymbol{x})=h_t(\boldsymbol{x}))+e^{\alpha_t}\mathbb{I}(f(\boldsymbol{x})\neq h_t(\boldsymbol{x}))] \\        &amp;=e^{-\alpha_t}P_{\boldsymbol{x}\sim\mathcal{D}_t}(f(\boldsymbol{x})=h_t(\boldsymbol{x})) + e^{\alpha_t}P_{\boldsymbol{x}\sim\mathcal{D}_t}(f(\boldsymbol{x})\neq h_t(\boldsymbol{x}))\\        &amp;=e^{-\alpha_t}(1-\epsilon_t)+e^{\alpha_t}\epsilon_t    \end{aligned}    \tag{6}\]</span> 其中 <span class="math inline">\(\epsilon_t=P_{\boldsymbol{x}\sim\mathcal{D}_t}(h_t(\boldsymbol{x})\neq f(\boldsymbol{x})\)</span> 则其导数 <span class="math display">\[    \frac{\partial\ell_{exp}(\alpha_th_t|\mathcal{D}_t)}{\partial\alpha_t}=-e^{-\alpha_t}(1-\epsilon_t)+e^{\alpha_t}\epsilon_t    \tag{7}\]</span> 令其为零可得到算法中的权重更新公式 <span class="math display">\[    \alpha_t=\frac{1}{2}ln(\frac{1-\epsilon_t}{\epsilon_t})    \tag{8}\]</span> AdaBoost 在获取 <span class="math inline">\(H_{t-1}\)</span> 之后样本分布将进行调整，使下一轮的 <span class="math inline">\(h_t\)</span> 能够纠正 <span class="math inline">\(H_{t-1}\)</span> 的全部错误，即最小化 <span class="math display">\[    \begin{aligned}        \ell_{exp}(H_{t-1}+h_t|\mathcal{D})        &amp;= \mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}} [e^{-f(\boldsymbol{x})(H_{t-1}(\boldsymbol{x}) + h_t(\boldsymbol{x}))}]\\        &amp;=\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}e^{-f(\boldsymbol{x})h_t(\boldsymbol{x}))}]    \end{aligned}    \tag{9}\]</span> 注意到 <span class="math inline">\(f^2(\boldsymbol{x})=h_t^2(\boldsymbol{x})=1\)</span>，则对 <span class="math inline">\(e^{-f(\boldsymbol{x})h_t(\boldsymbol{x}))}\)</span> 进行泰勒展开。 <span class="math display">\[    \begin{aligned}        \ell_{exp}(H_{t-1}+h_t|\mathcal{D})        &amp;\simeq \mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}(1-f(\boldsymbol{x})h_t(\boldsymbol{x})+\frac{f^2(\boldsymbol{x})h_t^2(\boldsymbol{x})}{2})]\\        &amp;=\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}(1-f(\boldsymbol{x})h_t(\boldsymbol{x})+\frac{1}{2})]    \end{aligned}    \tag{10}\]</span> 于是，理想的基学习器 <span class="math display">\[    \begin{aligned}        h_t(\boldsymbol{x})        &amp;=\mathop{\arg\min}_{h}\ell_{exp}(H_{t-1}+h|\mathcal{D})\\        &amp;=\mathop{\arg\min}_{h}\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}(1-f(\boldsymbol{x})h(\boldsymbol{x})+\frac{1}{2})]\\        &amp;=\mathop{\arg\max}_{h} \mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})} f(\boldsymbol{x})h(\boldsymbol{x})]\\        &amp;=\mathop{\arg\max}_{h} \mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[\frac{e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}}{\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}]} f(\boldsymbol{x})h(\boldsymbol{x})]    \end{aligned}    \tag{11}\]</span> <span class="math inline">\(\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}_t}[e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}]\)</span> 为常数，令 <span class="math inline">\(\mathcal{D}_t\)</span> 表示一个分布 <span class="math display">\[    \mathcal{D}_t(\boldsymbol{x}) = \frac{\mathcal{D}(\boldsymbol{x})e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}}{\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}]}    \tag{12}\]</span> 由数学期望的定义，其等价于令 <span class="math display">\[    \begin{aligned}        h_t(\boldsymbol{x})&amp;=\arg\max_h        \mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[\frac{e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}}{\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}_t}[e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}]} f(\boldsymbol{x})h(\boldsymbol{x})] \\        &amp;=\arg\max_h \mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}_t}[f(\boldsymbol{x})h(\boldsymbol{x})]    \end{aligned}    \tag{13}\]</span> 由于 <span class="math inline">\(f(\boldsymbol{x})h(\boldsymbol{x} \in \{-1, +1\})\)</span> ，有 <span class="math display">\[    f(\boldsymbol{x})h(\boldsymbol{x})=1-2\mathbb{I}(f(\boldsymbol{x}) \neq h(\boldsymbol{x}))    \tag{14}\]</span> 则理想的基学习器 <span class="math display">\[    h_t(\boldsymbol{x})=\arg\min_h    \mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}_t}    [\mathbb{I}(f(\boldsymbol{x}) \neq h(\boldsymbol{x}))]    \tag{15}\]</span> 由此可见，理想的基学习器 <span class="math inline">\(h_t(x)\)</span> 能在 <span class="math inline">\(\mathcal{D}_t\)</span> 下最小化误差。因此弱分类器应基于分布 <span class="math inline">\(\mathcal{D}_t\)</span> 训练，且分类误差应小于 <span class="math inline">\(0.5\)</span> 。这在一定程度上类似于“残差逼近”的思想，考虑到 <span class="math inline">\(\mathcal{D}_t\)</span> 与 <span class="math inline">\(\mathcal{D}_{t+1}\)</span> 的关系，有 <span class="math display">\[    \begin{aligned}        \mathcal{D}_{t+1}(\boldsymbol{x})        &amp;= \frac{\mathcal{D}(\boldsymbol{x})e^{-f(\boldsymbol{x})H_{t}(\boldsymbol{x})}}        {\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t}(\boldsymbol{x})}]}\\        &amp;= \frac{\mathcal{D}(\boldsymbol{x})e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}e^{-f(\boldsymbol{x})\alpha_th_t(\boldsymbol{x})}}        {\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t}(\boldsymbol{x})}]}\\        &amp;=\mathcal{D}_{t}(\boldsymbol{x})e^{-f(\boldsymbol{x})\alpha_th_t(\boldsymbol{x})}        \frac{\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}]}        {\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t}(\boldsymbol{x})}]}    \end{aligned}    \tag{16}\]</span> 即为算法中的样本分布更新公式。</p><p>于是由式 <span class="math inline">\((8)\)</span> 和 式 <span class="math inline">\((16)\)</span> 可见，我们从基于加法模型分步向前优化指数损失函数的角度推导出了AdaBoost算法。</p><h3 id="算法特性"><strong>算法特性</strong></h3><p>AdaBoost算法要求基学习器能对特定的数据分布进行学习，这可通过“重赋权法” (re-weighting) 实施，即在训练过程的每一轮中，根据样本分布为每个训练样本重新赋予一个权重。需要注意的是Boosting学习器在每一轮训练都要检查当前生成的基学习器是否满足基本条件 (例如AdaBoost每一轮都要检测基学习器是否比随机猜测好)，一旦条件不满足当前基学习器即被抛弃，且学习过程停止。</p><p>从偏差-方差分解的角度看，Boosting算发主要关注降低偏差，因此Boosting算法族能基于泛化能力相当弱的学习器构建出来很强的集成。</p><h2 id="参考文献"><strong>参考文献</strong></h2><ul><li><a href="http://zh.wikipedia.org/zh-cn/AdaBoost" target="_blank" rel="noopener">Wikipedia上关于AdaBoost的介绍</a></li><li>《机器学习》周志华著，第8章</li><li>《统计学习方法》李航著，第8章</li><li><a href="https://blog.csdn.net/v_JULY_v/article/details/40718799" target="_blank" rel="noopener">Adaboost 算法的原理与推导</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Boosting </tag>
            
            <tag> 集成学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习算法笔记-决策树</title>
      <link href="/2017/04/10/Decition_tree/"/>
      <url>/2017/04/10/Decition_tree/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>决策树（Decision Tree）是一种常见的机器学习方法。决策树基于树形结构进行决策，其每个非叶节点表示一个某属性集上的划分，每个分支代表这个特征属性在某个值域上的输出，每个叶节点则对应一个类别。本文主要总结一些基础的决策树算法。</p><h2 id="决策树基本算法">决策树基本算法</h2><p>输入:<br>训练集 <span class="math inline">\(D\)</span> = <span class="math inline">\(\{(x_1, y_1), (x_2, y_2), ..., (x_m, y_m)\}\)</span><br>属性集 <span class="math inline">\(A\)</span> = <span class="math inline">\(\{(a_1, a_2, ..., a_d)\}\)</span></p><p>过程：函数 <span class="math inline">\(TreeGenerate(G, A)\)</span><br>if <span class="math inline">\(D\)</span> 中的样本全属于同一类别 <span class="math inline">\(C\)</span> then<br>  将node标记为 <span class="math inline">\(C\)</span> 类叶节点; return<br>end if<br>if <span class="math inline">\(A\)</span> = <span class="math inline">\(\emptyset\)</span> OR <span class="math inline">\(D\)</span> 中的样本在 <span class="math inline">\(A\)</span> 上的取值相同 then<br>  将node标记为叶节点，类别为 <span class="math inline">\(D\)</span> 中样本最多的一类; return<br>end if<br>从 <span class="math inline">\(A\)</span> 中选择最优化分属性 <span class="math inline">\(a_*\)</span><br>for <span class="math inline">\(a_*\)</span> 的每一个取值 <span class="math inline">\(a_{*}^{v}\)</span> do<br>  为node生成一个分支；令 <span class="math inline">\(D_v\)</span> 表示 <span class="math inline">\(D\)</span> 中在 <span class="math inline">\(a_*\)</span> 上取值为 <span class="math inline">\(a_{*}^{v}\)</span> 的样本子集;<br>  if <span class="math inline">\(D_v\)</span> 为空 then<br>   将分支结点标记为叶节点，其类别标记为 <span class="math inline">\(D\)</span> 中样本最多的类; return<br>  else<br>  以 <span class="math inline">\(TreeGenerate(D_v, A \setminus\{a_*\})\)</span> 为分支结点<br> end if<br>end for</p><h2 id="属性划分">属性划分</h2><p>假定当前样本集合 <span class="math inline">\(D\)</span> 中第 <span class="math inline">\(k\)</span> 类样本所占比例为 <span class="math inline">\(p_k\)</span> (<span class="math inline">\(k\)</span> = 1,2, ... ,<span class="math inline">\(\mathcal{|Y|}\)</span>)</p><p>1.信息熵 <span class="math display">\[Ent(D) = - \sum_{k=1}^{|\mathcal{Y}|}p_klog_2p_k\]</span> 2.信息增益 <span class="math display">\[ Gain(D, a) = Ent(D)-\sum_{v=1}^{V}\frac{\lvert D^v\rvert}{\lvert D \rvert}Ent(D^v)\]</span></p><p>3.信息增益率 <span class="math display">\[Gain\_ratio = \frac{Gain(D, a)}{IV(a)}\]</span> <span class="math display">\[IV(a) = -\sum_{v=1}^{V}\frac{|D^v|}{|D|}log_2\frac{|D^v|}{|D|}\]</span> 4.基尼系数 <span class="math display">\[Gini(D)=\sum_{k=1}^{|\mathcal{Y}|}\sum_{k^{`} \neq k}p_k p_{k^`}\]</span> <span class="math display">\[Gini\_index(D,a) = \sum_{v=1}^{V}\frac{|D^v|}{|D|}Gini(D^v)\]</span></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>

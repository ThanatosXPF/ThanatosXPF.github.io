<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>修复 mhddfs 崩溃的问题 (Transport endpoint is not connected)</title>
      <link href="/2019/04/24/mhddfs-crash/"/>
      <url>/2019/04/24/mhddfs-crash/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>本文主要关于解决 <code>mhddfs</code> 1.39版本使用时遇到的bug问题（Transport endpoint is not connected），以及简要分析导致问题的原因。</p><a id="more"></a><p>去年使用 <code>mhddfs</code> 统合服务器上的多块大容量硬盘（<a href="https://mors.xyz/2018/06/10/Linux%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/" target="_blank" rel="noopener">链接</a>）。但是之后偶尔会出现由于大规模io（主要是写入，删除之类的操作）导致（或许） mhddfs 崩溃的问题。出现如下字样</p><pre><code>Transport endpoint is not connected</code></pre><p>此时运行 <code>ps auxw | grep mhddfs</code> 没有输出，mhddfs 已经停止运行。查看日志 <code>/var/log/kern.log</code> 发现 mhdfs 由于一个 <code>segfault</code> quit。</p><pre><code>mhddfs[11861]: segfault at 0 ip 0000000000404750 sp 00007f1100ff8a40 error 4 in mhddfs[400000+b000]</code></pre><p>由于挂载点失效，所有涉及向这个挂载点io的程序都会中断，而且该错误出现的莫名其妙，令人头秃。最近经过查阅发现这个 bug 已经被修复，经验证修复后暂未出现如同之前一样crash的情况。</p><h2 id="修复过程">修复过程</h2><p>安装依赖</p><pre><code>sudo apt install git fuse libfuse-dev libattr1-dev</code></pre><p>下载修复了 bug 的 mhddfs 源码并编译</p><pre><code>git clone https://github.com/vdudouyt/mhddfs-nosegfault/cd mhddfs-nosegfaultmakesudo cp mhddfs /usr/bin</code></pre><p>然后重新挂载</p><pre><code>sudo umount &lt;mount point&gt;sudo mount -a</code></pre><h2 id="原因分析">原因分析</h2><p>该错误仅出现在1.39版本，观察1.38到1.39的唯一一次 <a href="https://github.com/crass/mhddfs/commit/c62547d50a574ed9e3b04a8533be1c350b08c2ea" target="_blank" rel="noopener">commit</a> ,发现 <code>HASH_CLEAN</code> 存在一个 use after free 的问题 ( <a href="https://github.com/crass/mhddfs/blob/c62547d50a574ed9e3b04a8533be1c350b08c2ea/src/main.c#L246-L251" target="_blank" rel="noopener">here</a> )，该问题代码会由于调用 <code>HASH_CLEAR</code> 导致访问一个已经被 <code>free</code> 的 <code>node</code>。</p><h2 id="参考">参考</h2><ul><li><a href="https://nramkumar.org/tech/blog/2015/09/23/mhddfs-crash-with-ubuntu-14-04/" target="_blank" rel="noopener">mhddfs crash with Ubuntu 14.04 Ram's Tech Blog</a></li><li><a href="https://github.com/vdudouyt/mhddfs-nosegfault" target="_blank" rel="noopener">mhdffs-nosegfault</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Mhddfs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 16.04 cuda10.0 cudnn 7.4.1 tensorflow 1.13.1 环境配置</title>
      <link href="/2019/04/02/Ubuntu16.04+cuda10/"/>
      <url>/2019/04/02/Ubuntu16.04+cuda10/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>之前一段时间帮实验室的十几台电脑安装或者更新了Tensorflow环境，从最开始的安装 Cuda8.0 + Tensorflow 1.2.0 到前一段时间卸载 Cuda8.0 安装 Cuda10.0 和 Tensorflow 1.13.0。感觉有必要总结一下安装过程。</p><a id="more"></a><h2 id="卸载原有-nvidia-驱动以及-cuda">卸载原有 Nvidia 驱动以及 Cuda</h2><pre><code># sudo apt remove --purge nvidia*# sudo apt remove --purge cuda# sudo apt autoclean</code></pre><p>卸载完成后可以检查文件是否完全删除干净，路径 <code>/usr/local/</code> 如果没有看到 <code>cuda</code> 等文件夹则证明卸载完成。同时如果最初是使用的 deb 本地安装的 cuda，需要删除镜像源文件。</p><pre><code># cd /etc/apt/source.list.d# rm cuda*</code></pre><h2 id="禁用-nouveau">禁用 Nouveau</h2><p>只有在禁用 Nouveau 的情况下才能顺利安装 Nvidia 驱动。首先</p><pre><code># sudo vim /etc/modprobe.d/blacklist-nouveau.conf</code></pre><p>在最后一行加上</p><pre><code>blacklist nouveau</code></pre><p>可能这一步需要重启。（之前并没有遇到过这个对于重装环境的影响）</p><h2 id="安装新-cuda">安装新 Cuda</h2><p>这一步主要根据 <a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">NVIDIA 官方</a>的指导。对于 Cuda 10.0</p><pre><code># sudo dpkg -i cuda-repo-ubuntu1604-10-0-local-10.0.130-410.48_1.0-1_amd64.deb# sudo apt-key add /var/cuda-repo-&lt;version&gt;/7fa2af80.pub# sudo apt-get update# sudo apt-get install cuda</code></pre><p>安装结束后可以检测是否安装成功</p><pre><code># nvcc -Vnvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2018 NVIDIA CorporationBuilt on Sat_Aug_25_21:08:01_CDT_2018Cuda compilation tools, release 10.0, V10.0.130</code></pre><p>看到以上字样说明安装成功。</p><h2 id="安装-libcudnn">安装 libcudnn</h2><p>首先去官网下载相应 libcudnn 安装包，这里使用的 libcudnn 7.4.1，依次安装</p><pre><code>sudo dpkg -i libcudnn7_7.4.1.5-1+cuda10.0_amd64.debsudo dpkg -i libcudnn7-dev_7.4.1.5-1+cuda10.0_amd64.debsudo dpkg -i libcudnn7-doc_7.4.1.5-1+cuda10.0_amd64.deb</code></pre><h2 id="验证安装">验证安装</h2><p>输入命令 <code>nvidia-smi</code> ，如果输出显卡的信息则证明安装成功。若出现</p><pre><code># nvidia-smiFailed to initialize NVML: Driver/library version mismatch</code></pre><p>一般可以重启解决。但也可以尝试不重启的解决方法。我们可以尝试 unload 目前的驱动模块，load 正确版本的驱动。</p><pre><code># lsmod | grep nvidia</code></pre><p>可能会出现结果</p><pre><code>nvidia_uvm            634880  8nvidia_drm             53248  0nvidia_modeset        790528  1 nvidia_drmnvidia              12312576  86 nvidia_modeset,nvidia_uvm</code></pre><p>依次 unload 这些模块</p><pre><code>sudo rmmod nvidia_drmsudo rmmod nvidia_modesetsudo rmmod nvidia_uvmsudo rmmod nvidia</code></pre><p>在这个过程中可能会出现 <code>rmmod: ERROR: Module nvidia is in use</code> 的情况，说明有进程在使用驱动模块，我们需要终止这些进程。</p><pre><code>sudo lsof /dev/nvidia*</code></pre><p>然后一一 <code>kill</code> 掉，通过 <code>lsmod | grep nvidia</code> 来确定是否成功的 unload。之后通过 <code>nvidia-smi</code> 检查正确的驱动版本是否能被加载，若可以，则安装成功。</p><h2 id="安装-tenseofow">安装 Tenseofow</h2><p>直接使用 <code>pip</code> 进项安装，若速度较慢则可以尝试更换镜像源。安装之前记得删除旧的 TensorFlow</p><pre><code># pip install tensorflow-gpu==1.13.1</code></pre><p>打开ipython等</p><pre><code>import tensroflow as tfsess = tf.Session()</code></pre><p>若正确输出显卡信息则安装成功。</p>]]></content>
      
      
      <categories>
          
          <category> Technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Technique </tag>
            
            <tag> Environment </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 347. Top K Frequent Elements</title>
      <link href="/2018/07/10/leetcode347-TopKFrequentElements/"/>
      <url>/2018/07/10/leetcode347-TopKFrequentElements/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><strong>问题描述</strong></h2><p>Given a non-empty array of integers, return the k most frequent elements.</p><a id="more"></a><p>Example 1:</p><pre><code>Input: nums = [1,1,1,2,2,3], k = 2Output: [1,2]</code></pre><p>Example 2:</p><pre><code>Input: nums = [1], k = 1Output: [1]</code></pre><p>Note:</p><ul><li>You may assume k is always valid, 1 ≤ k ≤ number of unique elements.</li><li>Your algorithm's time complexity must be better than O(n log n), where n is the array's size.</li></ul><h2 id="解题思路"><strong>解题思路</strong></h2><p>统计每个元素出现的次数。按次数排序取前k个。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        d = collections.Counter(nums)</span><br><span class="line">        <span class="keyword">return</span> sorted(d.keys(), key=<span class="keyword">lambda</span> x:d[x], reverse=<span class="keyword">True</span>)[:k]</span><br></pre></td></tr></table></figure><h2 id="进阶"><strong>进阶</strong></h2><p>使用堆取前k大的元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> heapq</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">topKFrequent</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; List[int]:</span></span><br><span class="line">        l = [(-counts, elem) <span class="keyword">for</span> elem, counts <span class="keyword">in</span> collections.Counter(nums).items()]</span><br><span class="line">        heapq.heapify(l)</span><br><span class="line">        <span class="keyword">return</span> [heapq.heappop(l)[<span class="number">1</span>] <span class="keyword">for</span> i <span class="keyword">in</span> range(k)]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> Heap </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode题之回溯法</title>
      <link href="/2018/07/02/Leetcode-BackTrace/"/>
      <url>/2018/07/02/Leetcode-BackTrace/</url>
      
        <content type="html"><![CDATA[<h2 id="前言-关于回溯法">前言-关于回溯法</h2><h3 id="什么是回溯法">什么是回溯法</h3><p>回溯算法实际上一个类似枚举的搜索尝试过程，主要是在搜索尝试过程中寻找问题的解，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。</p><a id="more"></a><p>回溯法是一种选优搜索法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法，而满足回溯条件的某个状态的点称为“回溯点”。</p><p>许多复杂的，规模较大的问题都可以使用回溯法，有“通用解题方法”的美称。但是同时回溯法也容易遇到递归次数过多的问题影响时间复杂度，这时候就要开始考虑进行减支或者尝试DP算法。</p><h3 id="基本思想">基本思想</h3><p>在包含问题的所有解的解空间树中，按照深度优先搜索的策略，从根结点出发深度探索解空间树。当探索到某一结点时，要先判断该结点是否包含问题的解，如果包含，就从该结点出发继续探索下去，如果该结点不包含问题的解，则逐层向其祖先结点回溯。（其实回溯法就是对隐式图的深度优先搜索算法）。</p><p>若用回溯法求问题的所有解时，要回溯到根，且根结点的所有可行的子树都要已被搜索遍才结束。</p><p>而若使用回溯法求任一个解时，只要搜索到问题的一个解就可以结束。</p><h3 id="一般步骤">一般步骤</h3><pre><code>（1）针对所给问题，确定问题的解空间：首先应明确定义问题的解空间，问题的解空间应至少包含问题的一个（最优）解。（2）确定结点的扩展搜索规则。（3）以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索。</code></pre><h3 id="算法框架">算法框架</h3><ol style="list-style-type: decimal"><li>问题框架</li></ol><p>设问题的解是一个n维向量 <span class="math inline">\((a_1,a_2,………,a_n)\)</span>，约束条件是 <span class="math inline">\(a_i(i=1,2,3,…..,n)\)</span> 之间满足某种条件，记为<span class="math inline">\(f(a_i)\)</span>。</p><ol start="2" style="list-style-type: decimal"><li><p>非递归回溯框架</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[n],i;</span><br><span class="line">初始化数组a[];</span><br><span class="line">i = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i&gt;<span class="number">0</span>(有路可走)   <span class="keyword">and</span>  (未达到目标))&#123;  <span class="comment">// 还未回溯到头</span></span><br><span class="line">    <span class="keyword">if</span>(i &gt; n)&#123;    <span class="comment">// 搜索到叶结点</span></span><br><span class="line">        搜索到一个解，输出；</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123; <span class="comment">// 处理第i个元素</span></span><br><span class="line">        a[i]第一个可能的值；</span><br><span class="line">        <span class="keyword">while</span>(a[i]在不满足约束条件且在搜索空间内)&#123;</span><br><span class="line">            a[i]下一个可能的值；</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a[i]在搜索空间内)&#123;</span><br><span class="line">            标识占用的资源；</span><br><span class="line">            i = i+<span class="number">1</span>;  <span class="comment">// 扩展下一个结点</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            清理所占的状态空间； <span class="comment">// 回溯</span></span><br><span class="line">            i = i – <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>递归回溯框架</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[n];</span><br><span class="line"><span class="keyword">try</span>(<span class="keyword">int</span> i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&gt;n)</span><br><span class="line">        输出结果;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(j = 下界; j &lt;= 上界; j=j+<span class="number">1</span>)&#123;  <span class="comment">// 枚举i所有可能的路径</span></span><br><span class="line">            <span class="keyword">if</span>(fun(j))&#123;                 <span class="comment">// 满足限界函数和约束条件</span></span><br><span class="line">                a[i] = j;</span><br><span class="line">                ...                         <span class="comment">// 其他操作</span></span><br><span class="line">                <span class="keyword">try</span>(i+<span class="number">1</span>);</span><br><span class="line">                回溯前的清理工作（如a[i]置空值等）;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="leetcode-17.-letter-combinations-of-a-phone-number">Leetcode 17. Letter Combinations of a Phone Number</h2><h3 id="题目描述-for-17">题目描述 for 17</h3><p>Given a string containing digits from 2-9 inclusive, return all possible letter combinations that the number could represent.</p><p>A mapping of digit to letters (just like on the telephone buttons) is given below. Note that 1 does not map to any letters.</p><div class="figure"><img src="https://ss1.bdstatic.com/70cFuXSh_Q1YnxGkpoWK1HF6hhy/it/u=1933922589,3540416166&amp;fm=26&amp;gp=0.jpg" alt="phone number"><p class="caption">phone number</p></div><p>Example:</p><pre><code>Input: &quot;23&quot;Output: [&quot;ad&quot;, &quot;ae&quot;, &quot;af&quot;, &quot;bd&quot;, &quot;be&quot;, &quot;bf&quot;, &quot;cd&quot;, &quot;ce&quot;, &quot;cf&quot;].Note:</code></pre><p>Although the above answer is in lexicographical order, your answer could be in any order you want.</p><h3 id="解题思路-遍历">解题思路-遍历</h3><p>遍历每一个数字代表的不同字母，找出所有组合。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">letterCombinations</span><span class="params">(self, digits: str)</span> -&gt; List[str]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> digits:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        d = &#123;<span class="string">'2'</span>:[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>],</span><br><span class="line">            <span class="string">'3'</span>:[<span class="string">'d'</span>,<span class="string">'e'</span>,<span class="string">'f'</span>],</span><br><span class="line">            <span class="string">'4'</span>:[<span class="string">'g'</span>,<span class="string">'h'</span>,<span class="string">'i'</span>],</span><br><span class="line">            <span class="string">'5'</span>:[<span class="string">'j'</span>,<span class="string">'k'</span>,<span class="string">'l'</span>],</span><br><span class="line">            <span class="string">'6'</span>:[<span class="string">'m'</span>,<span class="string">'n'</span>,<span class="string">'o'</span>],</span><br><span class="line">            <span class="string">'7'</span>:[<span class="string">'p'</span>,<span class="string">'q'</span>,<span class="string">'r'</span>,<span class="string">'s'</span>],</span><br><span class="line">            <span class="string">'8'</span>:[<span class="string">'t'</span>,<span class="string">'u'</span>,<span class="string">'v'</span>],</span><br><span class="line">            <span class="string">'9'</span>:[<span class="string">'w'</span>,<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'z'</span>]&#125;</span><br><span class="line">        result = d[digits[<span class="number">0</span>]]</span><br><span class="line">        <span class="keyword">for</span> s <span class="keyword">in</span> digits[<span class="number">1</span>:]:</span><br><span class="line">            al = d[s]</span><br><span class="line">            temp = []</span><br><span class="line">            <span class="keyword">for</span> r <span class="keyword">in</span> result:</span><br><span class="line">                <span class="keyword">for</span> a <span class="keyword">in</span> al:</span><br><span class="line">                    temp.append(r+a)</span><br><span class="line">            result = temp</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="leetcode-22.-generate-parentheses">Leetcode 22. Generate Parentheses</h2><h3 id="问题描述-for-22">问题描述 for 22</h3><p>Given n pairs of parentheses, write a function to generate all combinations of well-formed parentheses.</p><p>For example, given n = 3, a solution set is:</p><pre><code>[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</code></pre><h3 id="解题思路-bt">解题思路-BT</h3><p>递归的找到所有合理解，通过一个变量 <code>state</code> 验证当前序列是否合法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generateParenthesis</span><span class="params">(self, n: int)</span> -&gt; List[str]:</span></span><br><span class="line">        result = []</span><br><span class="line">        self.gen(result, n, <span class="string">""</span>, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">gen</span><span class="params">(self, res, n, s, state)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(s) == <span class="number">2</span>*n:</span><br><span class="line">            <span class="keyword">if</span> state == <span class="number">0</span>:</span><br><span class="line">                res.append(s)</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="comment"># 如果 state 小于0则代表当前右括号比左括号多</span></span><br><span class="line">        <span class="keyword">if</span> state &lt; <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        self.gen(res, n, s+<span class="string">"("</span>, state+<span class="number">1</span>)</span><br><span class="line">        self.gen(res, n, s+<span class="string">")"</span>, state<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h2 id="leetcode-46.-permutations">Leetcode 46. Permutations</h2><h3 id="题目描述-for-46">题目描述 for 46</h3><p>Given a collection of distinct integers, return all possible permutations.</p><p>Example:</p><pre><code>Input: [1,2,3]Output:[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></pre><h3 id="解题思路-递归">解题思路-递归</h3><p>通过递归的方式遍历所有可能的结果。对每个不在 <code>temp</code> 中的元素，现考虑它在此位置的情况，再pop，考虑其他元素在此处的地方。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">permute</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        result = []</span><br><span class="line">        self.trace(result, [], nums)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(self, result, temp, nums)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> len(temp) == len(nums):</span><br><span class="line">            result.append(temp.copy())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">                <span class="keyword">if</span> nums[i] <span class="keyword">not</span> <span class="keyword">in</span> temp:</span><br><span class="line">                    temp.append(nums[i])</span><br><span class="line">                    self.trace(result, temp, nums)</span><br><span class="line">                    temp.pop(<span class="number">-1</span>)</span><br></pre></td></tr></table></figure><h2 id="leetcode-78.-subsets">Leetcode 78. Subsets</h2><h3 id="题目描述-for-78">题目描述 for 78</h3><p>Given a set of distinct integers, nums, return all possible subsets (the power set).</p><p>Note: The solution set must not contain duplicate subsets.</p><p>Example:</p><pre><code>Input: nums = [1,2,3]Output:[[3],[1],[2],[1,2,3],[1,3],[2,3],[1,2],[]]</code></pre><h3 id="解题思路-还是递归">解题思路-还是递归</h3><p>使用递归的方式，对每种组合进行考虑。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">subsets</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">trace</span><span class="params">(result, temp, nums, i)</span>:</span></span><br><span class="line">            result.append(temp)</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(i, len(nums)):</span><br><span class="line">                trace(result, temp+[nums[i]], nums, i+<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        result = []</span><br><span class="line">        trace(result, [], nums, <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="leetcode-79.-word-search">Leetcode 79. Word Search</h2><h3 id="问题描述-for-79">问题描述 for 79</h3><p>Given a 2D board and a word, find if the word exists in the grid.</p><p>The word can be constructed from letters of sequentially adjacent cell, where &quot;adjacent&quot; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p>Example:</p><pre><code>board =[[&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;E&#39;],[&#39;S&#39;,&#39;F&#39;,&#39;C&#39;,&#39;S&#39;],[&#39;A&#39;,&#39;D&#39;,&#39;E&#39;,&#39;E&#39;]]Given word = &quot;ABCCED&quot;, return true.Given word = &quot;SEE&quot;, return true.Given word = &quot;ABCB&quot;, return false.</code></pre><h3 id="解题思路-从每个点进行递归">解题思路-从每个点进行递归</h3><p>从每个点开始递归遍历，如果找到正确答案则返回，否则继续。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(board, x, y, word, i)</span>:</span></span><br><span class="line">            <span class="comment"># x, y 代表当前所在单元，i表示已经找到的字长</span></span><br><span class="line">            <span class="keyword">if</span> i == len(word):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="comment"># 越界检查，以及当前单元代表字符跟word里相应位置的是否一致</span></span><br><span class="line">            <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> x == len(board) <span class="keyword">or</span> y == len(board[<span class="number">0</span>]) <span class="keyword">or</span> board[x][y] != word[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="comment"># 对目前所在的单元进行已读标记</span></span><br><span class="line">            tmp = board[x][y]</span><br><span class="line">            board[x][y] = <span class="string">"#"</span></span><br><span class="line">            <span class="comment"># 单元格的四个方向查找</span></span><br><span class="line">            exists = find(board, x+<span class="number">1</span>, y, word, i+<span class="number">1</span>) \</span><br><span class="line">                <span class="keyword">or</span> find(board, x, y+<span class="number">1</span>, word, i+<span class="number">1</span>) \</span><br><span class="line">                <span class="keyword">or</span> find(board, x<span class="number">-1</span>, y, word, i+<span class="number">1</span>) \</span><br><span class="line">                <span class="keyword">or</span> find(board, x, y<span class="number">-1</span>, word, i+<span class="number">1</span>)</span><br><span class="line">            <span class="comment"># 恢复board的已读标记</span></span><br><span class="line">            board[x][y] = tmp</span><br><span class="line">            <span class="keyword">return</span> exists</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        h = len(board)</span><br><span class="line">        w = len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> find(board, i, j, word, <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="参考">参考</h2><ul><li><a href="https://www.cnblogs.com/steven_oyj/archive/2010/05/22/1741376.html" target="_blank" rel="noopener">五大常用算法之四：回溯法</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Back Trace </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 240. Search a 2D Matrix II</title>
      <link href="/2018/06/24/leetcode240/"/>
      <url>/2018/06/24/leetcode240/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><strong>问题描述</strong></h2><p>Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:</p><ul><li>Integers in each row are sorted in ascending from left to right.</li><li>Integers in each column are sorted in ascending from top to bottom.</li></ul><a id="more"></a><p>Example:</p><p>Consider the following matrix:</p><pre><code>[    [1,   4,  7, 11, 15],    [2,   5,  8, 12, 19],    [3,   6,  9, 16, 22],    [10, 13, 14, 17, 24],    [18, 21, 23, 26, 30]]</code></pre><p>Given <code>target</code> = 5, return <code>true</code>.</p><p>Given <code>target</code> = 20, return <code>false</code>.</p><h2 id="解题思路"><strong>解题思路</strong></h2><p>先找到 <code>target</code> 可能在的行，然后在行内使用二分查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> matrix:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> matrix[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">binary_search</span><span class="params">(nums, target)</span>:</span></span><br><span class="line">            l = <span class="number">0</span></span><br><span class="line">            r = len(nums) - <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span>(l &lt;= r):</span><br><span class="line">                m = (l + r) // <span class="number">2</span></span><br><span class="line">                <span class="keyword">if</span> nums[m] == target:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">elif</span> nums[m] &lt; target:</span><br><span class="line">                    l = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(matrix)</span><br><span class="line">        <span class="keyword">for</span> nums <span class="keyword">in</span> matrix:</span><br><span class="line">            <span class="keyword">if</span> nums[<span class="number">0</span>] &gt; target:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">if</span> nums[<span class="number">-1</span>] &lt; target:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            <span class="keyword">if</span> binary_search(nums, target):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="进阶"><strong>进阶</strong></h2><p>对整个矩阵进行二分查找，或者进行分块儿查找。首先看整个矩阵 <code>((0, 0), (m-1, n-1))</code>，中点 <code>((m-1)//2, (n-1)//2)</code> 通过对比中点数据大小和target大小，确定target在哪个区域。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        m = len(matrix)</span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        n = len(matrix[<span class="number">0</span>])</span><br><span class="line">        X = [(<span class="number">0</span>, <span class="number">0</span>, m - <span class="number">1</span>, n - <span class="number">1</span>)]</span><br><span class="line">        <span class="keyword">while</span> X:</span><br><span class="line">            i, j, k, l = X.pop()</span><br><span class="line">            <span class="keyword">if</span> i &gt; k <span class="keyword">or</span> j &gt; l <span class="keyword">or</span> \</span><br><span class="line">                matrix[i][j] &gt; target <span class="keyword">or</span> matrix[k][l] &lt; target:</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            p, q = (i + k)// <span class="number">2</span>, (j + l) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> matrix[p][q] == target:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> matrix[p][q] &lt; target:</span><br><span class="line">                X += [(p + <span class="number">1</span>, j, k, q), (<span class="number">0</span>, q + <span class="number">1</span>, k, l)]</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                X += [(i, j, k, q - <span class="number">1</span>), (<span class="number">0</span>, q, p - <span class="number">1</span>, l)]</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h2 id="python耍赖做法"><strong>Python耍赖做法</strong></h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchMatrix</span><span class="params">(self, matrix, target)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type matrix: List[List[int]]</span></span><br><span class="line"><span class="string">        :type target: int</span></span><br><span class="line"><span class="string">        :rtype: bool</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">return</span> any(target <span class="keyword">in</span> row <span class="keyword">for</span> row <span class="keyword">in</span> matrix)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 215. Kth Largest Element in an Array</title>
      <link href="/2018/06/22/leetcode215-KthLargestElementInAnArray/"/>
      <url>/2018/06/22/leetcode215-KthLargestElementInAnArray/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><strong>问题描述</strong></h2><p>Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.</p><a id="more"></a><p>Example 1:</p><pre><code>Input: [3,2,1,5,6,4] and k = 2Output: 5</code></pre><p>Example 2:</p><pre><code>Input: [3,2,3,1,2,4,5,5,6] and k = 4Output: 4</code></pre><p>Note:</p><ul><li>You may assume k is always valid, 1 ≤ k ≤ array's length.</li></ul><h2 id="解题思路"><strong>解题思路</strong></h2><p>堆排序，建堆O(logn)，取前k个，总时间复杂度O(klogn)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">import</span> heapq</span><br><span class="line">        <span class="keyword">return</span> heapq.nlargest(k, nums)[<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="进阶"><strong>进阶</strong></h2><p>快排方法，将比pivot小的移动到pivot左边大的移动到右边，如果结束后pivot位于第k个则pivot即为答案。如果大于k则从pivot左边找，小于则从右边找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findKthLargest</span><span class="params">(self, nums: List[int], k: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">return</span> self.partition( <span class="number">0</span>, len(nums) - <span class="number">1</span>, nums, len(nums) - k)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">partition</span><span class="params">(self, l, r, nums, k)</span>:</span></span><br><span class="line"></span><br><span class="line">        pivoti = random.randint(l, r)</span><br><span class="line">        pivot = nums[pivoti]</span><br><span class="line">        nums[pivoti], nums[r] = nums[r], nums[pivoti]</span><br><span class="line"></span><br><span class="line">        L = l</span><br><span class="line">        R = r - <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> L &lt;= R:</span><br><span class="line">            <span class="keyword">while</span> nums[L] &lt; pivot:</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">            <span class="keyword">while</span> nums[R] &gt; pivot:</span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> L &lt;= R:</span><br><span class="line">                nums[L], nums[R] = nums[R], nums[L]</span><br><span class="line">                L += <span class="number">1</span></span><br><span class="line">                R -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        nums[L], nums[r] = nums[r], nums[L]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> L == k:</span><br><span class="line">            <span class="keyword">return</span> nums[L]</span><br><span class="line">        <span class="keyword">elif</span> L &gt; k:</span><br><span class="line">            <span class="keyword">return</span> self.partition(l, L - <span class="number">1</span>, nums, k)</span><br><span class="line">        <span class="keyword">elif</span> L &lt; k:</span><br><span class="line">            <span class="keyword">return</span> self.partition(L + <span class="number">1</span>, r,  nums, k)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> Heap </tag>
            
            <tag> Quick Sort </tag>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 79.Word Search</title>
      <link href="/2018/06/19/leetcode79-WordSearch/"/>
      <url>/2018/06/19/leetcode79-WordSearch/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><strong>问题描述</strong></h2><p>Given a 2D board and a word, find if the word exists in the grid.</p><a id="more"></a><p>The word can be constructed from letters of sequentially adjacent cell, where &quot;adjacent&quot; cells are those horizontally or vertically neighboring. The same letter cell may not be used more than once.</p><p>Example:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">board =</span><br><span class="line">[</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'E'</span>],</span><br><span class="line">  [<span class="string">'S'</span>,<span class="string">'F'</span>,<span class="string">'C'</span>,<span class="string">'S'</span>],</span><br><span class="line">  [<span class="string">'A'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'E'</span>]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">Given word = <span class="string">"ABCCED"</span>, <span class="keyword">return</span> true.</span><br><span class="line">Given word = <span class="string">"SEE"</span>, <span class="keyword">return</span> true.</span><br><span class="line">Given word = <span class="string">"ABCB"</span>, <span class="keyword">return</span> false.</span><br></pre></td></tr></table></figure><h2 id="解题思路"><strong>解题思路</strong></h2><p>回朔法，从board中每个元素出发遍历周围的四个元素，查看是否能组成部分答案，若能，则继续从该元素出发进行查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">exist</span><span class="params">(self, board: List[List[str]], word: str)</span> -&gt; bool:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(board, x, y, word, i)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> i == len(word):</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> x &lt; <span class="number">0</span> <span class="keyword">or</span> y &lt; <span class="number">0</span> <span class="keyword">or</span> x == len(board) <span class="keyword">or</span> y == len(board[<span class="number">0</span>]) <span class="keyword">or</span> board[x][y] != word[i]:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            tmp = board[x][y]</span><br><span class="line">            board[x][y] = <span class="string">"#"</span></span><br><span class="line">            exists = find(board, x+<span class="number">1</span>, y, word, i+<span class="number">1</span>) \</span><br><span class="line">                <span class="keyword">or</span> find(board, x, y+<span class="number">1</span>, word, i+<span class="number">1</span>) \</span><br><span class="line">                <span class="keyword">or</span> find(board, x<span class="number">-1</span>, y, word, i+<span class="number">1</span>) \</span><br><span class="line">                <span class="keyword">or</span> find(board, x, y<span class="number">-1</span>, word, i+<span class="number">1</span>)</span><br><span class="line">            board[x][y] = tmp</span><br><span class="line">            <span class="keyword">return</span> exists</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> board:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        h = len(board)</span><br><span class="line">        w = len(board[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(len(board)):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(len(board[<span class="number">0</span>])):</span><br><span class="line">                <span class="keyword">if</span> find(board, i, j, word, <span class="number">0</span>):</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Back Trace </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 162. Find Peak Element</title>
      <link href="/2018/06/13/leetcode162-FindPeakElements/"/>
      <url>/2018/06/13/leetcode162-FindPeakElements/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><strong>问题描述</strong></h2><p>A peak element is an element that is greater than its neighbors.</p><p>Given an input array nums, where nums[i] ≠ nums[i+1], find a peak element and return its index.</p><a id="more"></a><p>The array may contain multiple peaks, in that case return the index to any one of the peaks is fine.</p><p>You may imagine that nums[-1] = nums[n] = -∞.</p><p>Example 1:</p><pre><code>Input: nums = [1,2,3,1]Output: 2Explanation: 3 is a peak element and your function should return the index number 2.</code></pre><p>Example 2:</p><pre><code>Input: nums = [1,2,1,3,5,6,4]Output: 1 or 5Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6.</code></pre><p>Note:</p><p>Your solution should be in logarithmic complexity.</p><h2 id="解决思路"><strong>解决思路</strong></h2><p>因为题目要求对数复杂度，而且是一个查找问题，直觉使用二分查找。与二分查找的不同在于对high重新赋值为mid而不是mid-1，因为我们希望mid在 <code>nums[mid] &gt; nums[mid+1]</code> 的同时再比较一次 <code>nums[mid-1] 和 nums[mid]</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">findPeakElement</span><span class="params">(self, nums: <span class="string">'List[int]'</span>)</span> -&gt; 'int':</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        low, high = <span class="number">0</span>, n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> low &lt; high:</span><br><span class="line">            mid = (low+high)//<span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[mid] &lt; nums[mid+<span class="number">1</span>]:</span><br><span class="line">                low = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid</span><br><span class="line">        <span class="keyword">return</span> low</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 挂载多块大容量硬盘</title>
      <link href="/2018/06/10/Linux%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/"/>
      <url>/2018/06/10/Linux%E6%8C%82%E8%BD%BD%E7%A1%AC%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>最近实验室采购了十台服务器，每台服务器配备了4块4T机械硬盘，本文记录了硬盘的挂载过程，以及虚拟存储工具 mhddfs 的使用。</p><a id="more"></a><p>4块机械硬盘分别为 /dev/sda, /dev/sdb, /dev/sdc, /dev/sdd.</p><h2 id="步骤">步骤</h2><ul><li>查看硬盘信息</li><li>查看挂载信息</li><li>分区命令</li><li>格式化分区</li><li>开机自动挂载</li><li>多硬盘合并挂载 mhddfs</li></ul><h2 id="查看硬盘信息">查看硬盘信息</h2><p>可以使用 <code>fdisk</code> 命令，fdisk 命令可以观察硬盘实体使用情况。</p><pre><code># sudo fdisk -lh</code></pre><p>通过命令可以看到目前系统中有哪些硬盘，以及它们各自的分区。</p><h2 id="查看挂载信息">查看挂载信息</h2><p>通过 <code>df</code> 命令可以查看硬盘的挂载信息。</p><pre><code># df -lhFilesystem                   Size  Used Avail Use% Mounted onudev                          32G     0   32G   0% /devtmpfs                        6.3G   18M  6.3G   1% /run/dev/mapper/ubuntu--vg-root  869G   63G  763G   8% /tmpfs                         32G     0   32G   0% /dev/shmtmpfs                        5.0M  4.0K  5.0M   1% /run/locktmpfs                         32G     0   32G   0% /sys/fs/cgroup/dev/nvme0n1p2               473M  149M  301M  34% /boot/dev/nvme0n1p1               511M  3.6M  508M   1% /boot/efitmpfs                        6.3G     0  6.3G   0% /run/user/1000</code></pre><p>可以看到目前系统中仅挂载了一块固态硬盘。</p><h2 id="分区命令">分区命令</h2><p><code>fdisk</code> 命令不仅可以用于观察硬盘实体使用情况，也可以对硬盘进行分区。但 <code>fdisk</code> 命令进行分区最多仅支持2T容量。所以对于4T硬盘，可以使用 <code>parted</code> 命令进行分区。</p><p><code>parted</code> 命令是由GNU组织开发的一款功能强大的磁盘分区和分区大小调整工具，与 <code>fdisk</code> 不同，它支持调整分区的大小。作为一种设计用于Linux的工具，它没有构建成处理与 <code>fdisk</code> 关联的多种分区类型，但是，它可以处理最常见的分区格式，包括：ext2、ext3、fat16、fat32、NTFS、ReiserFS、JFS、XFS、UFS、HFS以及Linux交换分区。</p><pre><code># sudo parted /dev/sdaGNU Parted 3.2Using /dev/sdaWelcome to GNU Parted! Type &#39;help&#39; to view a list of commands.(parted) mklabel gpt(parted) unit TB(parted) mkpart primary 0 4(parted) pGNU Parted 3.2Using /dev/sdaWelcome to GNU Parted! Type &#39;help&#39; to view a list of commands.Model: ATA ST4000NM0035-1V4 (scsi)Disk /dev/sda: 4001GBSector size (logical/physical): 512B/512BPartition Table: gptDisk Flags:Number  Start   End     Size    File system  Name     Flags1      1049kB  4001GB  4001GB               primary</code></pre><h2 id="格式化分区">格式化分区</h2><p>使用 <code>mkfs</code> 命令，将创建好的分区格式化为 ext4 格式。</p><pre><code># sudo mkfs.ext4 /dev/sda1</code></pre><h2 id="开机自动挂载">开机自动挂载</h2><p>通过 <code>blkid</code> 命令查看硬盘UUID</p><pre><code># sudo blkid/dev/nvme0n1p1: UUID=&quot;6062-5002&quot; TYPE=&quot;vfat&quot; PARTUUID=&quot;23340a62-728f-4a13-855d-12783a6745d9&quot;/dev/nvme0n1p2: UUID=&quot;058309c1-a4f4-42d4-a011-9c59f331d327&quot; TYPE=&quot;ext2&quot; PARTUUID=&quot;c3b8246a-4753-414d-be15-1dd85840a949&quot;/dev/nvme0n1p3: UUID=&quot;wr77H2-n6Qt-BKuF-4IdY-IE2S-4fFk-Du7c06&quot; TYPE=&quot;LVM2_member&quot; PARTUUID=&quot;4f0227e4-d948-4dee-9e54-ba022051073b&quot;/dev/mapper/ubuntu--vg-root: UUID=&quot;5fb8ed79-a83b-4d34-a6d3-d554dfeb3d2e&quot; TYPE=&quot;ext4&quot;/dev/sda1: UUID=&quot;a520f550-1807-475d-8737-72733444d48f&quot; TYPE=&quot;ext4&quot; PARTLABEL=&quot;primary&quot; PARTUUID=&quot;94dbf9bb-924d-40a5-99b1-a1116801aeaa&quot;/dev/sdb1: UUID=&quot;085423aa-4578-4dda-a7d5-5c6b85feadb2&quot; TYPE=&quot;ext4&quot; PARTLABEL=&quot;primary&quot; PARTUUID=&quot;47eee203-601d-48d4-937c-ff45a9a17222&quot;/dev/sdc1: UUID=&quot;ade474c4-e8b2-4cc6-804d-802a283f164d&quot; TYPE=&quot;ext4&quot; PARTLABEL=&quot;primary&quot; PARTUUID=&quot;2885a317-a2b4-4d0c-aebb-97c6fb8c56e3&quot;/dev/sdd1: UUID=&quot;ce9dda21-86ac-4c6b-aac3-5d464d348e52&quot; TYPE=&quot;ext4&quot; PARTLABEL=&quot;primary&quot; PARTUUID=&quot;f48c33d8-3170-4802-bab5-ee1e0add763c&quot;/dev/mapper/ubuntu--vg-swap_1: UUID=&quot;4f617909-ed55-45ba-85ce-b1d211b44fca&quot; TYPE=&quot;swap&quot;/dev/nvme0n1: PTUUID=&quot;2fff60a6-1c9d-43f2-9b4f-182dced404e2&quot; PTTYPE=&quot;gpt&quot;</code></pre><p>修改 /etc/fstab 文件，加入表项</p><pre><code>UUID= /mnt/A ext4 defaults 0 2</code></pre><p>将挂载硬盘的UUID填入。在相应位置创建挂载点（/mnt/A）并修改权限。 使用命令 <code>mount</code> 挂载硬盘</p><pre><code># sudo mount /dev/sda1</code></pre><h2 id="多硬盘合并挂载-mhddfs">多硬盘合并挂载 <code>mhddfs</code></h2><p>现在已经将4块硬盘都挂载在了相应的文件夹下 (/mnt/A /mnt/B /mnt/C /mnt/D) 但是由于过多的挂载点导致文件分散在不同的目录下，对于访问文件十分不利。所以可以使用 <code>mhddfs</code> 将多个硬盘挂载在一个路径下。也称作 Linux 分区合并，即 Linux 挂载点合并。</p><p><code>mhddfs</code> 是一个 FUSE 系统模块，它可以将多个 Linux 分区(挂载点)或硬盘组合成一个虚拟驱动器。这样我们就可以将文件丢到 <code>mhddfs</code> 创建的虚拟驱动器中，它会自动将文件分布到不同的挂载点中，而用户看起来就像是放到了一个统一的路径。</p><p><code>mhddfs</code> 安装</p><pre><code># sudo apt install mhddfs</code></pre><p>创建挂载点并修改权限后，使用命令</p><pre><code># sudo mhddfs /mnt/A,/mnt/B,/mnt/C,/mnt/D /extend -o allow_other</code></pre><p>在 /etc/fstab 中写入</p><pre><code>mhddfs#/mnt/A,/mnt/B,/mnt/C,/mnt/D /extend fuse defaults,allow_other 0 0</code></pre><p>以实现开机自动挂载</p>]]></content>
      
      
      <categories>
          
          <category> Technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> Hard Drive </tag>
            
            <tag> Mount </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 动态规划</title>
      <link href="/2018/06/10/Leetcode-DP/"/>
      <url>/2018/06/10/Leetcode-DP/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>最近做了 Leetcode 一些 Dynamic Programming 相关的题目，记录一下思路和解法。</p><a id="more"></a><h2 id="leetcode-55.-jump-game">Leetcode 55. Jump Game</h2><h3 id="题目描述">题目描述</h3><p>Given an array of non-negative integers, you are initially positioned at the first index of the array.</p><p>Each element in the array represents your maximum jump length at that position.</p><p>Determine if you are able to reach the last index.</p><p>Example 1:</p><pre><code>Input: [2,3,1,1,4]Output: trueExplanation: Jump 1 step from index 0 to 1, then 3 steps to the last index.</code></pre><p>Example 2:</p><pre><code>Input: [3,2,1,0,4]Output: falseExplanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index.</code></pre><h3 id="解题思路1暴力递归">解题思路1：暴力递归</h3><p>遍历每一个元素，每一种跳跃可能，若某一遍历达到随后则返回 <code>True</code>. 但是该方法问题在于时间效率太低，最坏情况下要遍历每一种可能。会发生Time Exceeding</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump_game</span><span class="params">(self, nums)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">jump</span><span class="params">(nums)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="number">0</span> <span class="keyword">not</span> <span class="keyword">in</span> nums:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> nums[<span class="number">0</span>] == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">if</span>  len(nums) &gt; <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                print(nums)</span><br><span class="line">                c = nums[<span class="number">0</span>]</span><br><span class="line">                <span class="keyword">if</span> c &gt;= len(nums) - <span class="number">1</span>:</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                <span class="keyword">while</span> c:</span><br><span class="line">                    <span class="keyword">if</span> jump(nums[c:]):</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">                    <span class="keyword">else</span>:</span><br><span class="line">                        c -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> jump(nums):</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br></pre></td></tr></table></figure><h3 id="解题思路2-dp">解题思路2: DP</h3><p>遍历过程中保存当前元素下可进行跳跃的最大距离，若最大距离小于等于0而还没有达到数组结尾，返回 <code>False</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: List[int])</span> -&gt; bool:</span></span><br><span class="line">        l = len(nums)</span><br><span class="line">        max_step= <span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(l):</span><br><span class="line">            <span class="keyword">if</span> max_step - <span class="number">1</span> &gt; nums[i]:</span><br><span class="line">                max_step -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                max_step = nums[i]</span><br><span class="line">            <span class="keyword">if</span> max_step &lt;= <span class="number">0</span> <span class="keyword">and</span> i != l<span class="number">-1</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span></span><br></pre></td></tr></table></figure><h3 id="解题思路3另一种途径">解题思路3：另一种途径</h3><p>从后向前，<code>last</code> 记录在哪个位置可以跳到最后。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">canJump</span><span class="params">(self, nums: <span class="string">'List[int]'</span>)</span> -&gt; 'bool':</span></span><br><span class="line">        n = len(nums)</span><br><span class="line">        <span class="keyword">if</span> n==<span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">        last = n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(n<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">            <span class="comment"># 如果第i能跳到last的位置，i就成为新的last</span></span><br><span class="line">            <span class="keyword">if</span> i + nums[i] &gt;= last:</span><br><span class="line">                last = i</span><br><span class="line">        <span class="keyword">return</span> last==<span class="number">0</span></span><br></pre></td></tr></table></figure><h2 id="leetcode-62.-unique-paths">Leetcode 62. Unique Paths</h2><h3 id="问题描述">问题描述</h3><p>A robot is located at the top-left corner of a m x n grid (marked 'Start' in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked 'Finish' in the diagram below).</p><p>How many possible unique paths are there?</p><div class="figure"><img src="https://assets.leetcode.com/uploads/2018/10/22/robot_maze.png" alt="maze img"><p class="caption">maze img</p></div><p>Above is a 7 x 3 grid. How many possible unique paths are there?</p><p><strong>Note:</strong> m and n will be at most 100.</p><p>Example 1:</p><pre><code>Input: m = 3, n = 2Output: 3Explanation:From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:1. Right -&gt; Right -&gt; Down2. Right -&gt; Down -&gt; Right3. Down -&gt; Right -&gt; Right</code></pre><p>Example 2:</p><pre><code>Input: m = 7, n = 3Output: 28</code></pre><h3 id="解题思路-1.-暴力递归法">解题思路 1. 暴力递归法</h3><p>通过递归遍历每一种可能的走法。但该方法的问题也在于时间复杂度过高，<span class="math inline">\(O(2^{mn})\)</span>。会导致Time Exceeding</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">find</span><span class="params">(m, n)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> m == <span class="number">0</span> <span class="keyword">and</span> n == <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">elif</span> m &lt; <span class="number">0</span> <span class="keyword">or</span> n &lt; <span class="number">0</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">False</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                find(m<span class="number">-1</span>, n)</span><br><span class="line">                find(m, n<span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> find(m, n)</span><br></pre></td></tr></table></figure><h3 id="解题思路2.-dp">解题思路2. DP</h3><p>思路一是通过自上向下递归，试图找到最优解。我们可以换个思路，是否可以从重点出发，计算它邻近的节点达到它的所有可能路径。所以一个点达到终点的可能路径为与他相邻的右方和下方两点可能路径之和。 -- 杨辉三角</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">uniquePaths</span><span class="params">(self, m: int, n: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> m &lt;= <span class="number">0</span> <span class="keyword">or</span> n &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">        <span class="keyword">if</span> m == <span class="number">1</span> <span class="keyword">or</span> n == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">        res = [[<span class="number">1</span> <span class="keyword">for</span> _ <span class="keyword">in</span> range(m)] <span class="keyword">for</span> _ <span class="keyword">in</span> range(n)]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">1</span>, m):</span><br><span class="line">                res[i][j] = res[i<span class="number">-1</span>][j]+res[i][j<span class="number">-1</span>]</span><br><span class="line">        <span class="keyword">return</span> res[n<span class="number">-1</span>][m<span class="number">-1</span>]</span><br></pre></td></tr></table></figure><h2 id="leetcode-322.-coin-change">Leetcode 322. Coin Change</h2><h3 id="题目描述-for-322">题目描述 for 322</h3><p>You are given coins of different denominations and a total amount of money amount. Write a function to compute the fewest number of coins that you need to make up that amount. If that amount of money cannot be made up by any combination of the coins, return -1.</p><p>Example 1:</p><pre><code>Input: coins = [1, 2, 5], amount = 11Output: 3Explanation: 11 = 5 + 5 + 1</code></pre><p>Example 2:</p><pre><code>Input: coins = [2], amount = 3Output: -1</code></pre><p><strong>Note:</strong> You may assume that you have an infinite number of each kind of coin.</p><h3 id="解题思路-dp">解题思路-DP</h3><p>计算从 <code>0</code> 到 <code>amount</code> 所花费的最少的硬币数。当前 <code>amount</code> 为 <code>n</code> 时，选择 <code>n - c</code> 时的硬币数 <code>+ 1</code> 取值最小的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> Max = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(amount + <span class="number">1</span>, Max);</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">1</span>; i &lt;=amount; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;coins.size(); j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> c = coins[j];</span><br><span class="line">                <span class="keyword">if</span> (i &gt;= c)</span><br><span class="line">                    res[i] = min(res[i-c] + <span class="number">1</span>, res[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[amount]&gt;amount?<span class="number">-1</span>:res[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="进阶思路-递归加减支">进阶思路-递归加减支</h3><p>基本还是递归的思想，但是增加了减支条件，如果剩下的钱都能被某个最大的 <code>coin</code> 整除，则直接加全部用这个面值硬币的硬币数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX, n = coins.size();</span><br><span class="line">        sort(coins.begin(), coins.end());</span><br><span class="line">        helper(coins, n - <span class="number">1</span>, amount, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> (res == INT_MAX) ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> start, <span class="keyword">int</span> target, <span class="keyword">int</span> cur, <span class="keyword">int</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &lt; <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (target % coins[start] == <span class="number">0</span>) &#123;</span><br><span class="line">            res = min(res, cur + target / coins[start]);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = target / coins[start]; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur + i &gt;= res - <span class="number">1</span>) <span class="keyword">break</span>;</span><br><span class="line">            helper(coins, start - <span class="number">1</span>, target - i * coins[start], cur + i, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="leetcode-300.-longest-increasing-subsequence">Leetcode 300. Longest Increasing Subsequence</h2><h3 id="问题描述-1">问题描述</h3><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p><p>Example:</p><pre><code>Input: [10,9,2,5,3,7,101,18]Output: 4 Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4. </code></pre><p>Note:</p><ul><li>There may be more than one LIS combination, it is only necessary for you to return the length.</li><li>Your algorithm should run in O(n2) complexity.</li></ul><p>Follow up: Could you improve it to O(n log n) time complexity?</p><h3 id="解题思路1-dp">解题思路1-DP</h3><p>状态设计: <code>dp[i]</code> 代表以 <code>nums[i]</code> 结尾的 LIS 长度。</p><p>状态转移: <code>dp[i] = max(dp[i], dp[j]+1) (0&lt;=j&lt;i, a[j]&lt;a[i])</code></p><p>边界处理: <code>dp[i] = 1 (0&lt;=j&lt;n)</code></p><p>时间复杂度: O(N^2)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp (nums.size(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> n = nums.size();</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;n; i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j &lt; i; j ++)&#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; nums[j])&#123;</span><br><span class="line">                    dp[i] = max(dp[i], dp[j]+<span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            l = max(l, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="进阶思路-贪心二分查找">进阶思路 贪心+二分查找</h3><p>第一步中在第二个循环查找插入的子序列时可以优化为二分查找，时间复杂度变为 O(nlogn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ends&#123;nums[<span class="number">0</span>]&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a &lt; ends[<span class="number">0</span>]) ends[<span class="number">0</span>] = a;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (a &gt; ends.back()) ends.push_back(a);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> left = <span class="number">0</span>, right = ends.size();</span><br><span class="line">                <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                    <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                    <span class="keyword">if</span> (ends[mid] &lt; a) left = mid + <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span> right = mid;</span><br><span class="line">                &#125;</span><br><span class="line">                ends[right] = a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ends.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="进阶写法-lower_bound">进阶写法 <code>lower_bound</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; last;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = lower_bound(last.begin(), last.end(), num);</span><br><span class="line">            <span class="keyword">if</span> (it == last.end()) &#123;</span><br><span class="line">                last.push_back(num);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                *it = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> last.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> Dynamic Programming </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Samba共享文件</title>
      <link href="/2018/06/05/Samba/"/>
      <url>/2018/06/05/Samba/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>最近因为很多原因需要共享一个 Ubuntu 系统下的文件夹供他人访问，于是决定使用 samba 。</p><a id="more"></a><h2 id="关于samba">关于samba</h2><p>Samba是在Linux和UNIX系统上实现SMB协议的一个免费软件，由服务器及客户端程序构成。SMB（Server Messages Block，信息服务块）是一种在局域网上共享文件和打印机的一种通信协议，它为局域网内的不同计算机之间提供文件及打印机等资源的共享服务。SMB协议是客户机/服务器型协议，客户机通过该协议可以访问服务器上的共享文件系统、打印机及其他资源。通过设置“NetBIOS over TCP/IP”使得Samba不但能与局域网络主机分享资源，还能与全世界的电脑分享资源。</p><p>SMB（Server Message Block）通信协议是微软（Microsoft）和英特尔(Intel)在1987年制定的协议，主要是作为Microsoft网络的通讯协议。SMB 是在会话层（session layer）和表示层（presentation layer）以及小部分应用层（application layer）的协议。 SMB使用了NetBIOS的应用程序接口 （Application Program Interface，简称API）。另外，它是一个开放性的协议，允许了协议扩展——使得它变得更大而且复杂；大约有65个最上层的作业，而每个作业都超过120个函数，甚至Windows NT也没有全部支持到，最近微软又把 SMB 改名为 CIFS（Common Internet File System），并且加入了许多新的特色。</p><h2 id="环境">环境</h2><pre><code>Ubuntu 16.044.13.0-43-generic</code></pre><h2 id="samba-安装">Samba 安装</h2><pre><code># sudo apt install samba</code></pre><h2 id="samba-配置参数说明">Samba 配置参数说明</h2><p>Samba 服务的配置文件位于 /etc/samba/smb.conf</p><h3 id="全局文件配置参数">全局文件配置参数</h3><pre><code>[global]    config file = /etc/samba/smb.conf.%U       #可以让你使用另一个配置文件来覆盖缺省的配置文件。如果文件 不存在，则该项无效。    workgroup = WORKGROUP                      #工作组名称    server string = Samba Server Version %v    #主机的简易说明    netbios name = MYSERVER                    #主机的netBIOS名称，如果不填写则默认服务器DNS的一部分，workgroup和netbios name名字不要设置成一样    interfaces = lo eth0 192.168.12.2/24 192.168.13.2/24                                                 #设置samba服务器监听网卡，可以写网卡名称或IP地址，默认注释    hosts allow = 127. 192.168.12. 192.168.13. #设置允许连接到samba服务器的客户端，默认注释    hosts deny = 192.168.12.0/255.255.255.0    #设置不允许连接到samba服务器的客户端，默认注释    log level = 1                              #日志文件安全级别，0~10级别，默认0    log file = /var/log/samba/%m               #产生日志文件的命名，默认以访问者IP地址命名    max log size = 50                          #日志文件最大容量50，默认50，单位为KB，0表示不限制</code></pre><h3 id="自定义共享文件配置参数">自定义共享文件配置参数</h3><pre><code>[share]                                        # 自定义共享名    comment = Home Directories                 # 描述符，是给系统管理员看的    path = /tmp                                # 共享的路径    public = yes                               # 是否公开，也就是是否能在网上邻居看到该共享    browseable = yes                           # 共享的目录是否让所有人可见    writable = yes                             # 是否可写    guest ok = no                              # 是否拒绝匿名访问，仅当安全级别为 share 时才生效    workgroup = WORKGROUP                      # 工作组，要设置成跟 Windows 的工作组一致    server string = Samba Server Version %v    # 其他 Linux 主机查看共享时的提示符    netbios name = MYSERVER                    # 用于在 Windows 网上邻居上显示的主机名    hosts allow = 127. 192.168.12. 192.168.13. EXCEPT 192.168.13.13   # 指定允许访问 samba 服务器的主机    security = share                           # 定义安全级别    log file = /var/log/samba/log.%m           # 定义日志文件，每个访问的主机会产生独立的日志文件，%m 是客户端主机名    max log size = 50                          # 定义单个日志的最大容量（KB）    passdb backend = tdbsam                    # Samba 用户的存储方式，smbpasswd 表示明文存储，tdbsam 表示密文存储    deadtime = 10                              # 客户端在10分钟内没有打开任何 Samba 资源，服务器将自动关闭会话。    display charset = UTF8                     # 设置显示的字符集    max connections = 0                        # 设置最大连接数，0表示无限制，如果超过最大连接数则拒绝连接    guest account = nobody                     # 设置匿名账户为nobody    load printers = yes                        # 是否在启动 Samba 时就共享打印机    cups options = raw                         # 设置打印机使用的方式    valid users = user1 user2 user3            # 指定哪些用户可以访问，如果不指定则所有用户都可访问    invalid users = user1 user2                # 指定哪些用户不可以访问    create mask = 0775                         # 客户端上传文件的默认权限    directory mask = 0775                      # 客户端创建目录的默认权限    write list = user1 user2 user3             # 设置可对文件进行写操作的用户    admin users = user1                        # 设置共享目录的管理员，具有完全权限    force create mode = 0775                   # Windows 与 Linux 具有不同的文件和文件夹默认权限，Windows下新建的文件是    force directory mode = 0775                # 可执行的，所以必须强制设定其权限</code></pre><h3 id="关于安全级别">关于安全级别</h3><pre><code>share ：表示匿名用户，不需要 samba 账户就可登陆 samba 服务器user ：系统账户要先添加进 samba 库然后变成 samba 用户，使用 samba 用户来登陆，简单来讲就是需要使用用户密码登录server ：由另外一台 samba 服务器来对用户进行身份验证domain ：把 samba 服务器加入到 NT 域，由 NT 的域控制器来进行身份验证ADS ：（Active Directory Service，活动目录服务），是 samba3.0 中新增的身份验证方式，采用 ADS 验证方式，samba 服务器集成到活动目录中</code></pre><h2 id="samba-配置">Samba 配置</h2><h3 id="实用的配置">实用的配置</h3><p>可以用此配置共享一个服务器上的所有文件，使浏览数据更加方便。<em>但这样做会产生一定的安全风险。</em></p><pre><code>[share]    path = /    public = yes    writable = yes    valid users = user    create mask = 0775    force create mode = 0775    directory mask = 0775    force directory mode = 0775    available = yes</code></pre><h3 id="设置登录密码">设置登录密码</h3><pre><code># sudo touch /etc/samba/smbpasswd# sudo smbpasswd -a                             # 根据设置的valid user，设置用户密码。</code></pre><h3 id="重启-samba-服务使配置生效">重启 Samba 服务使配置生效</h3><pre><code># sudo /etc/init.d/samba restart</code></pre><h2 id="连接">连接</h2><h3 id="通过-windows-连接">通过 Windows 连接</h3><p>在文件资源管理器输入</p><pre><code>\\(ip)</code></pre><h3 id="通过-linux-连接">通过 Linux 连接</h3><p>在 connect to server，输入</p><pre><code>smb://(ip)</code></pre>]]></content>
      
      
      <categories>
          
          <category> Technique </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Ubuntu </tag>
            
            <tag> share </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 75. Sort Colors</title>
      <link href="/2018/05/28/leetcode75-SortColor/"/>
      <url>/2018/05/28/leetcode75-SortColor/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><strong>问题描述</strong></h2><p>Given an array with n objects colored red, white or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white and blue.</p><a id="more"></a><p>Here, we will use the integers 0, 1, and 2 to represent the color red, white, and blue respectively.</p><p>Note: You are not suppose to use the library's sort function for this problem.</p><p>Example:</p><pre><code>Input: [2,0,2,1,1,0]Output: [0,0,1,1,2,2]</code></pre><p>Follow up:</p><ul><li>A rather straight forward solution is a two-pass algorithm using counting sort.</li><li>First, iterate the array counting number of 0's, 1's, and 2's, then overwrite array with total number of 0's, then 1's and followed by 2's. Could you come up with a one-pass algorithm using only constant space?</li></ul><h2 id="解题思路"><strong>解题思路</strong></h2><p>基本按照计数排序的思路，先遍历统计0、1、2的个数。根据个数重新对数组赋值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums: List[int])</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        count = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> nums:</span><br><span class="line">            count[i] += <span class="number">1</span></span><br><span class="line">        print(count)</span><br><span class="line">        print(nums[:count[i]])</span><br><span class="line">        nums[:count[<span class="number">0</span>]] = [<span class="number">0</span>]*count[<span class="number">0</span>]</span><br><span class="line">        nums[count[<span class="number">0</span>]:count[<span class="number">1</span>]+count[<span class="number">0</span>]] = [<span class="number">1</span>]*count[<span class="number">1</span>]</span><br><span class="line">        nums[count[<span class="number">1</span>]+count[<span class="number">0</span>]:] = [<span class="number">2</span>]*count[<span class="number">2</span>]</span><br></pre></td></tr></table></figure><h2 id="进阶思路"><strong>进阶思路</strong></h2><p>上述做法貌似需要 <span class="math inline">\(O(n)\)</span> 的额外存储空间，如果 <span class="math inline">\(O(1)\)</span> 来做又会导致遍历两次。因此可以考虑类似快速排序的做法，两个指针分别指向头尾，一个指针从左到右移动。。将遇到的2移动到最右边，遇到的0移动到最左边。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sortColors</span><span class="params">(self, nums: <span class="string">'List[int]'</span>)</span> -&gt; '<span class="keyword">None</span>':</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        Do not return anything, modify nums in-place instead.</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> len(nums)&lt;=<span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        i=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> i&lt;=r:</span><br><span class="line">            <span class="keyword">if</span> nums[i] == <span class="number">2</span> <span class="keyword">and</span> i&lt;r:</span><br><span class="line">                nums[i], nums[r] = nums[r], nums[i]</span><br><span class="line">                r-=<span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> nums[i] == <span class="number">0</span> <span class="keyword">and</span> i&gt;l:</span><br><span class="line">                nums[i], nums[l] = nums[l], nums[i]</span><br><span class="line">                l+=<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                i+=<span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 56. Merge Intervals</title>
      <link href="/2018/05/24/leetcode56/"/>
      <url>/2018/05/24/leetcode56/</url>
      
        <content type="html"><![CDATA[<h2 id="题目描述"><strong>题目描述</strong></h2><p>Given a collection of intervals, merge all overlapping intervals.</p><a id="more"></a><p>Example 1:</p><pre><code>Input: [[1,3],[2,6],[8,10],[15,18]]Output: [[1,6],[8,10],[15,18]]Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].</code></pre><p>Example 2:</p><pre><code>Input: [[1,4],[4,5]]Output: [[1,5]]Explanation: Intervals [1,4] and [4,5] are considered overlapping.</code></pre><h2 id="解题思路"><strong>解题思路</strong></h2><p>将所有的interval按开始时间排序，检测是否重叠，若重叠，检测结束时间。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">merge</span><span class="params">(self, intervals: List[List[int]])</span> -&gt; List[List[int]]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> intervals:</span><br><span class="line">            <span class="keyword">return</span> []</span><br><span class="line">        <span class="keyword">if</span> len(intervals) == <span class="number">1</span>:</span><br><span class="line">            <span class="keyword">return</span> intervals</span><br><span class="line">        intervals = sorted(intervals)</span><br><span class="line">        res = []</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> intervals:</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> res <span class="keyword">or</span> res[<span class="number">-1</span>][<span class="number">1</span>] &lt; i[<span class="number">0</span>]:</span><br><span class="line">                res.append(i)</span><br><span class="line">            <span class="keyword">elif</span> res[<span class="number">-1</span>][<span class="number">1</span>] &lt; i[<span class="number">1</span>]:</span><br><span class="line">                res[<span class="number">-1</span>][<span class="number">1</span>] = i[<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 34. Find First and Last Position of Element in Sorted Array</title>
      <link href="/2018/05/23/leetcode34-FindFirstandLastPositionofElementInSortedArray/"/>
      <url>/2018/05/23/leetcode34-FindFirstandLastPositionofElementInSortedArray/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><strong>问题描述</strong></h2><p>Given an array of integers nums sorted in ascending order, find the starting and ending position of a given target value.</p><a id="more"></a><p>Your algorithm's runtime complexity must be in the order of <span class="math inline">\(O(log n)\)</span>.</p><p>If the target is not found in the array, return [-1, -1].</p><p>Example 1:</p><pre><code>Input: nums = [5,7,7,8,8,10], target = 8Output: [3,4]</code></pre><p>Example 2:</p><pre><code>Input: nums = [5,7,7,8,8,10], target = 6Output: [-1,-1]</code></pre><h2 id="解题思路"><strong>解题思路</strong></h2><p>对数时间复杂度，优先考虑二分查找，先找出目标数的左界。通常做法，二分查找对于右指针的更新改为mid而不是mid-1。然后查找target的右界，同样使用二分查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searchRange</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; List[int]:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> [<span class="number">-1</span>,<span class="number">-1</span>]</span><br><span class="line">        n = len(nums)</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            m = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &lt; target:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="comment"># 对于有界的更新进行改动，这样可以保证找到的m一定是target左界</span></span><br><span class="line">                r = m</span><br><span class="line">        <span class="keyword">if</span> nums[l] != target: <span class="keyword">return</span> <span class="number">-1</span>, <span class="number">-1</span></span><br><span class="line">        left = l</span><br><span class="line">        l, r = left, n<span class="number">-1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            m = (l+r) // <span class="number">2</span> + <span class="number">1</span></span><br><span class="line">            <span class="comment"># 对条件进行改动，使其找到的是第一个非target，即为右界</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == target:</span><br><span class="line">                l = m</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = m<span class="number">-1</span></span><br><span class="line">        <span class="keyword">return</span> left, l</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Leetcode 33. Search in Rotated Sorted Array</title>
      <link href="/2018/05/23/leetcode33/"/>
      <url>/2018/05/23/leetcode33/</url>
      
        <content type="html"><![CDATA[<h2 id="问题描述"><strong>问题描述</strong></h2><p>Suppose an array sorted in ascending order is rotated at some pivot unknown to you beforehand.</p><a id="more"></a><p>(i.e., [0,1,2,4,5,6,7] might become [4,5,6,7,0,1,2]).</p><p>You are given a target value to search. If found in the array return its index, otherwise return -1.</p><p>You may assume no duplicate exists in the array.</p><p>Your algorithm's runtime complexity must be in the order of O(log n).</p><p>Example 1:</p><pre><code>Input: nums = [4,5,6,7,0,1,2], target = 0Output: 4</code></pre><p>Example 2:</p><pre><code>Input: nums = [4,5,6,7,0,1,2], target = 3Output: -1</code></pre><h2 id="解题思路"><strong>解题思路</strong></h2><p>要求对数复杂度，首先考虑二分查找。先用二分查找找到最小值，然后再根据target所在区间进行二分查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> nums:</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            m = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] &gt; nums[r]:</span><br><span class="line">                l = m+<span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                r = m</span><br><span class="line">        s = l</span><br><span class="line">        l = <span class="number">0</span></span><br><span class="line">        r = len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> nums[s] &lt;= target &lt;= nums[r]:</span><br><span class="line">            l = s</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            r = s</span><br><span class="line">        <span class="keyword">while</span>(l &lt;= r):</span><br><span class="line">            m = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == target:</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">            <span class="keyword">elif</span> nums[m] &gt; target:</span><br><span class="line">                r = m - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l = m + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br></pre></td></tr></table></figure><h2 id="进阶"><strong>进阶</strong></h2><p>可以考虑只进行一次二分查找。通过比较mid和r确定pivot点的大概位置。如果m大于r，且 target 在l与m之间，重新在 (l, m-1) 查找，若不是，则在 (m+1, r) 之间查找。若m小于r，当 target 在m与r之间则在 (m+1, r) 内进行查找，否则在 (l, m-1) 内进行查找。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; int:</span></span><br><span class="line">        l, r = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> l &lt;= r:</span><br><span class="line">            m = (l + r) // <span class="number">2</span></span><br><span class="line">            <span class="keyword">if</span> nums[m] == target:</span><br><span class="line">                <span class="keyword">return</span> m</span><br><span class="line">            <span class="keyword">elif</span> nums[m] &gt; nums[r]:</span><br><span class="line">                <span class="keyword">if</span> nums[l] &lt;= target &lt;= nums[m]:</span><br><span class="line">                    r = m - <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    l = m + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                <span class="keyword">if</span> nums[m] &lt;= target &lt;= nums[r]:</span><br><span class="line">                    l = m + <span class="number">1</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    r = m - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">        <span class="comment"># Time: O(log(N))</span></span><br><span class="line">        <span class="comment"># Space: O(1)</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Leetcode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> Binary Search </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Boosting算法族三 XGBoost</title>
      <link href="/2017/10/30/Boosting3/"/>
      <url>/2017/10/30/Boosting3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><strong>前言</strong></h2><p>本文主要介绍XGBoost这一超快集成训练模型。该算法思想就是不断地添加树，不断地进行特征分裂来生长一棵树，每次添加一个树，其实是学习一个新函数去预测一个样本的分数，最后将每棵树对应的分数加起来就是该样本的预测值。</p><a id="more"></a><h2 id="推导"><strong>推导</strong></h2><p>目标函数定义</p><p><span class="math display">\[L(\phi)=\sum_i l(y_i,\hat{y}_i)+\sum_k \Omega(f_k) \\ \Omega(f_k)=\gamma T+\frac{1}{2}\lambda \|w\|^2\]</span></p><p>其中 <span class="math inline">\(\sum_i l(y_i,\hat{y}_i)\)</span> 代表损失函数，<span class="math inline">\(\sum_k \Omega(f_k)\)</span> 代表正则化项。<span class="math inline">\(\hat{y}_i\)</span> 代表预测输出， <span class="math inline">\(y_i\)</span> 代表真实值，<span class="math inline">\(f_k\)</span> 代表第 k 棵树， <span class="math inline">\(T\)</span> 为树叶子节点数，<span class="math inline">\(\omega\)</span> 为叶子权重值，<span class="math inline">\(\gamma\)</span> 为正则化系数。</p><p><span class="math display">\[\hat{y}_i=\phi(x_i)=\sum_{k=1}^Kf_k(x_i) \\where F=\{f(x)=w_{q(x)}\}  (q:R^m \rightarrow T,w \in R^T)\]</span></p><p>其中，<span class="math inline">\(w_{q(x)}\)</span> 是叶子节点 <span class="math inline">\(q\)</span> 的分数，函数 <span class="math inline">\(q(x)\)</span> 将样本 <span class="math inline">\(x\)</span> 映射到树上的某一叶子节点。<span class="math inline">\(f(x)\)</span> 是一颗回归树。对于任一样本 <span class="math inline">\(x\)</span>，其分值为 <span class="math inline">\(w_{q(x)}\)</span>。</p><p>目标函数可以重写为</p><p><span class="math display">\[Obj^{(t)}=\sum_{i=1}^{n} l(y_i,\hat{y}^{(t-1)}+f_t(x_i))+\Omega(f_t)+constant\]</span></p><p>接下来就是最小化目标函数。XGBoost 利用其泰勒二阶展开来近似。</p><p><span class="math display">\[Obj^{(t)} \simeq \sum_{i=1}^n [l(y_i,\hat{y}^{(t-1)})+g_if_t(x_i)+\frac{1}{2}h_if_t^2(x_i)] + \Omega(f_t) + constant \\g_i=\frac{\partial l(y_i,\hat{y}^{(t-1)})}{\partial \hat{y}^{(t-1)}}, h_i =\frac{\partial^2 l(y_i,\hat{y}^{(t-1)})}{\partial {\hat{y}^{(t-1)}}^2}\]</span></p><p>此处为什么使用二阶偏导数呢？</p><p>首先我们需要明确 boosting 每一轮迭代都是在优化什么。换言之，我们都在用损失函数 <span class="math inline">\(l\)</span> 干什么。我们看 Boosting 的框架，无论是 GBDT 还是 Adaboost，其在每一轮的迭代过程中并没有理会损失函数具体是什么，仅仅用到了损失函数的一阶导数。仅仅用一阶导数的问题就是我们无法保证我们找到的是全局最优。除非问题本身 <span class="math inline">\(f(x)\)</span> 是强凸的。每次迭代相当于最优化负梯度。即下式中的 <span class="math inline">\(\nabla f(x^{(i)})\)</span>，因为梯度为负所以加负号， <span class="math inline">\(c\)</span> 代表学习率。</p><p><span class="math display">\[x_c^{(i+1)}=x^{(i)}-c\nabla f(x^{(i)})\]</span></p><p>大家都能看出这就是一般长假的呢 Linear Regression 的 Stochastic Gradient Descend 梯度更新公式。既然 GBDT 用的是 SGD，那还有其他的梯度更新方式吗？所以我们想到了牛顿法。或许可以说，XGBoost 是利用了牛顿法进行的梯度更新。</p><p>首先看泰勒展开式：</p><p><span class="math display">\[\sum_{n=0}^\infty \frac{1}{n!}\frac{\partial ^nf(x)}{\partial x^n}\nabla x^n = f(x)+\frac{\partial f(x)}{\partial x}\nabla x + \frac{1}{2!}\frac{\partial^2f(x)}{\partial x^2}\nabla x^2 + ...\]</span></p><p>对于上式，其与 <span class="math inline">\(f(x+\nabla x)\)</span> 之间的误差，可以用下式表示:</p><p><span class="math display">\[f(x+\nabla x)-\sum_{n=0}^\infty \frac{1}{n!}\frac{\partial ^nf(x)}{\partial x^n}\nabla x^n=h_k(x)a^k\]</span></p><p>保留二阶泰勒展开:</p><p><span class="math display">\[f(x+\nabla x) \simeq f(x) + f&#39;(x)\nabla x+\frac{1}{2}f&#39;&#39;(x)\nabla x^2\]</span></p><p>这个式子是成立的，当且仅当 <span class="math inline">\(\nabla x\)</span>趋近于 0，我们对上式求导（对 <span class="math inline">\(\nabla x\)</span> 求导）并令导数为 0。</p><p><span class="math display">\[f&#39;(x)+f&#39;&#39;(x)\nabla x = 0\]</span></p><p>即得到:</p><p><span class="math display">\[\nabla x = -\frac{f&#39;(x)}{f&#39;&#39;(x)}\]</span></p><p>得出迭代公式</p><p><span class="math display">\[x_{n+1} = x_n - \frac{f&#39;(x)}{f&#39;&#39;(x)}\]</span></p><p>将损失函数与 <span class="math inline">\(f(x)\)</span> 对应起来:</p><p><span class="math display">\[\begin{aligned}    f(x)&amp;=l(y_i, \hat{y}_i^{(t-1)} ) \\    &amp;=(y_i - \hat{y}_i^{(t-1)})^2 \\    f(x+\Delta x)&amp;=l(y_i, \hat{y}_i^{(t-1)} + f_t(x_i)) \\    &amp;=(y_i - (\ \hat{y}_i^{(t-1)} + f_t(x_i)\ )\ )^2\end{aligned}\]</span></p><p>所以实际上 <span class="math inline">\(x\)</span> 即为 <span class="math inline">\(\hat{y}_i^{t-1}\)</span>，而 <span class="math inline">\(\nabla x\)</span> 即为 <span class="math inline">\(f_t(x_i)\)</span>。故对 <span class="math inline">\(f(x)\)</span> 求导数时即对 <span class="math inline">\(\hat{y}_i^{t-1}\)</span> 求偏导，故根据二阶泰勒展开，<span class="math inline">\(f(x+\nabla x\)</span> 可以表示为:</p><p><span class="math display">\[f(x+\nabla x)=(y_i-\hat{y}_i^{(t-1)})^2 + [(y_i-\hat{y}_i^{(t-1)})^2]&#39;*f_t(x_i) + \frac{1}{2}[(y_i-\hat{y}_i^{(t-1)})^2]&#39;&#39;*f_t^2(x_i)\]</span></p><p>用 <span class="math inline">\(g_i\)</span> 和 <span class="math inline">\(h_i\)</span> 替代上式中的 <span class="math inline">\(f&#39;(x)\)</span> 和 <span class="math inline">\(f&#39;&#39;(x)\)</span>，即可得到</p><p><span class="math display">\[\begin{aligned}\text{obj}^{(t)} = \sum_{i=1}^n [l(y_i, \hat{y}_i^{(t-1)}) + g_i f_t(x_i) + \frac{1}{2} h_i f_t^2(x_i)] + \Omega(f_t) + constant\end{aligned}\]</span></p><p>理解了一二阶偏导之后再来看正则化项:</p><p><span class="math display">\[\Omega(f_t)=\gamma T + \frac{1}{2}\lambda \|w\|^2\]</span></p><p>我们为了使目标函数最小，自然正则化项要小，正则化项要小，叶子节点个数 T 要小（叶子越少，树越简单）。</p><p>由于前 t-1 棵树的预测分数与 y 的残差对目标函数优化没有影响可以直接去掉，所以有:</p><p><span class="math display">\[Obj^{(t)}=\sum_{i-1}^n [g_i f_t(x_i) + \frac{1}{2} h_i f_t^2(x_i)] + \Omega(f_t)\]</span></p><p>上式是将每个样本的损失函数值加起来，我们知道，每个样本最终都会落到一个叶子节点上，所以我们可以将所有同一叶子节点的样本重组起来，过程如下:</p><p><span class="math display">\[\begin{aligned}Obj^{(t)}&amp;=\sum_{i-1}^n [g_i f_t(x_i) + \frac{1}{2} h_i f_t^2(x_i)] + \Omega(f_t) \\&amp;=\sum_{i=1}^n[g_i f_t(x_i) + \frac{1}{2} h_i f_t^2(x_i)] + \gamma T + \frac{1}{2}\lambda \sum_{j=1}^T w_j^2 \\&amp;=\sum_{j=1}^T[(\sum_{i \in I_j}g_i)w_j + \frac{1}{2}(\sum_{i \in I_j}h_i+\lambda)w_j^2]+\gamma T \\&amp;=\frac{1}{2} \sum_{j=1}^T(H_j+\lambda)(w_j + \frac{G_j}{H_j+\lambda})^2 + \gamma T - \frac{1}{2}\sum_{j=1}^T \frac{G_j^2}{H_j+\lambda} \\&amp;=\sum_{j=1}^T[G_jw_j + \frac{1}{2}(H_j + \lambda) w_j^2] + \gamma T\end{aligned}\]</span></p><p>其中 <span class="math inline">\(G_i = \sum_{i\in I_j} g_i\)</span> 为落入叶子 <span class="math inline">\(i\)</span> 的所有样本一阶梯度统计值综合，<span class="math inline">\(H_i=\sum_{i\in I_j} h_i\)</span> 为落入叶子 <span class="math inline">\(i\)</span> 所有样本二阶梯度统计值总和。</p><p>对 <span class="math inline">\(w_j\)</span> 求导可得</p><p><span class="math display">\[w_j^*=-\frac{G_j}{H_j+\lambda}\]</span></p><p>代入 <span class="math inline">\(w_j^*\)</span> 有</p><p><span class="math display">\[Obj=-\frac{1}{2}\sum_{j=1}^{T}\frac{G_j^2}{H_j+\lambda} + \gamma T\]</span></p><p><span class="math inline">\(Obj\)</span> 代表当我们指定一个树结构后，在目标上最多减少多少。因此叫做结构分数。</p><p>目前为止，我们一直在围绕目标函数进行分析。主要也是为了寻找 <span class="math inline">\(f_k(x)\)</span>，也就是建树的过程。回忆决策树算法，建树的时候最关键的一步就是选择一个分裂的准则，也就是如何评价分裂的质量。比如在 GBDT 里，我们可以选择 MSE、MAE 来评价我们分裂的质量。但是我们所选择的分裂准则并不总是和我们的损失函数有关，因为这种选择是启发式的。比如在分类任务里，损失函数可以选择 log loss，分裂准则选择 MSE，这样看来，似乎分裂的好坏和我们的损失并没有直接挂钩。</p><p>但是在 XGBoost 里面，我们的分裂准则是直接与损失函数挂钩的准则。这个也是 XGBoost 与 GBDT 很不一样的地方。</p><p>具体来说，XGBoost 选择这个准则计算增益 Gain</p><p><span class="math display">\[Gain=\frac{1}{2}[\frac{G_L^2}{H_L+\lambda}+ \frac{G_R^2}{H_R+\lambda}- \frac{(G_L + G_R)^2}{H_L+H_R+\lambda}]-\gamma\]</span></p><p>其中 <span class="math inline">\(G_L\)</span> 代表分裂的话左叶子节点中样本点的集合的一阶梯度和，<span class="math inline">\(G_R\)</span> 代表右边边界的。</p><p>当所有样本都存在于未分类的节点中，此时该节点中一阶导的和就相当于 <span class="math inline">\(G_L+G_R\)</span>，未分裂节点上的二阶导数为 <span class="math inline">\(H_L+H_R\)</span>，将其带入结构分数中，我们得到不分裂的情况下的结构分数。</p><p><span class="math display">\[\frac{(G_L + G_R)^2}{H_L+H_R+\lambda}\]</span></p><p>假设这个接点分裂，分类之后左右叶子节点的结构分数分别为:</p><p><span class="math display">\[\frac{G_L^2}{H_L+\lambda}\]</span></p><p><span class="math display">\[\frac{G_R^2}{H_R+\lambda}\]</span></p><p>分裂的时候我们选择分裂之后损失减少最多的，也就是找到一种分裂有着</p><p><span class="math display">\[\max (\frac{G_L^2}{H_L+\lambda}+ \frac{G_R^2}{H_R+\lambda}- \frac{(G_L + G_R)^2}{H_L+H_R+\lambda})\]</span></p><p>那么 <span class="math inline">\(\gamma\)</span> 的作用即为控制树的复杂度。进一步说，利用 <span class="math inline">\(\gamma\)</span> 作为阈值，只有当大于 <span class="math inline">\(\gamma\)</span> 时才选择分裂，也起到预剪枝的作用。</p><p>所以总结一下，XGBoost 主要做了以下几件事。</p><ol style="list-style-type: decimal"><li>在损失函数中加入了正则化项。</li><li>对目标函数进行二阶泰勒展开。</li><li>利用推导得到的表达式作为分裂准则构建每一棵树。</li></ol><h2 id="总结xgboost-与-gbdt-的区别与联系"><strong>总结：XGBoost 与 GBDT 的区别与联系</strong></h2><p>区别:</p><ol style="list-style-type: decimal"><li>xgboost和GBDT的一个区别在于目标函数上。在xgboost中，损失函数+正则项。 GBDT中一般只有损失函数。</li><li>xgboost中利用二阶导数的信息，而GBDT只利用了一阶导数, 即在GBDT回归中利用了残差的概念。</li><li>xgboost在建树的时候利用的准则来源于目标函数推导，即可以理解为牛顿法。而GBDT建树利用的是启发式准则。</li><li>xgboost中可以自动处理空缺值，自动学习空缺值的分裂方向，GBDT(sklearn版本)不允许包含空缺值。</li></ol><p>相似:</p><ol style="list-style-type: decimal"><li>xgboost和GBDT的学习过程都是一样的，都是基于Boosting的思想，先学习前n-1个学习器，然后基于前n-1个学习器学习第n个学习器。而且其都是将损失函数和分裂点评估函数分开了。</li><li>建树过程都利用了损失函数的导数信息。</li><li>都使用了学习率来进行Shrinkage，从前面我们能看到不管是GBDT还是xgboost，我们都会利用学习率对拟合结果做缩减以减少过拟合的风险。</li></ol><h2 id="参考"><strong>参考</strong></h2><ul><li><a href="https://www.wikiwand.com/en/XGBoost" target="_blank" rel="noopener">XGBoost Wikipedia</a></li><li><a href="https://www.jianshu.com/p/ac1c12f3fba1" target="_blank" rel="noopener">XGBoost详解 Teci著</a></li><li><a href="https://fengxc.me/GBDT%E8%AF%A6%E8%A7%A3.html" target="_blank" rel="noopener">GBDT与Xgboost详解 小川著</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Boosting </tag>
            
            <tag> 集成学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Boosting算法族二 BT, GBDT</title>
      <link href="/2017/10/18/Boosting2/"/>
      <url>/2017/10/18/Boosting2/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><strong>前言</strong></h2><p>本文续接<a href="https://mors.xyz/2017/10/09/Boosting1/" target="_blank" rel="noopener">上文</a>关于Adaboost的内容，继续记录 Boosting 算法族的其他算法。上一篇博客简单介绍了了加法模型和向前分布算法，以及 Adaboost 模型的原理和推导过程。本篇博客主要介绍 Boosted Decision Tree （提升树） 和 Bradient Boosting Decision Tree（GBDT）两种算法。其中 GDBT 可以理解为 BDT 的一种推广形式。</p><a id="more"></a><h2 id="boosted-decision-tree"><strong>Boosted Decision Tree</strong></h2><h3 id="算法">算法</h3><hr><p>输入: <span class="math inline">\(D = \{(\boldsymbol{x}^{(1)}, y^{(1)}), (\boldsymbol{x}^{(2)}, y^{(2)}), ... , (\boldsymbol{x}^{(m)}, y^{(m)})\}\)</span><br>输出: 提升树 <span class="math inline">\(f_k(\boldsymbol{x})\)</span><br>  (1) 初始化模型 <span class="math inline">\(f_0(\boldsymbol{x}) = 0\)</span><br>  (2) for t in 1,2, ..., k; do<br>    (a) 计算残差 <span class="math inline">\(r_t=y^{(t)} - f_{t-1}(\boldsymbol{x^{(i)}})\)</span><br>    (b) 拟合残差 <span class="math inline">\(r_{t}\)</span>，学习一个回归树，得到 <span class="math inline">\(T(\boldsymbol{x}; \theta_t)\)</span><br>    (c) 更新 <span class="math inline">\(f_t(\boldsymbol{x})=f_{t-1}(\boldsymbol{x})+T(\boldsymbol{x}; \theta_t)\)</span><br>  (3) 得到回归树 <span class="math inline">\(f_k(\boldsymbol{x})=\sum_{t=1}^KT(\boldsymbol{x};\theta_t)\)</span></p><hr><h3 id="简介">简介</h3><p>残差树是针对回归问题的一种提升方法。其基学习器是基于CART算法的回归树，模型依旧为加法模型、损失函数为平方函数、学习算法为前向分步算法。</p><p>其使用以下的前向分步算法：</p><p><span class="math display">\[\begin{aligned}   f_0(\boldsymbol{x})&amp;=0 \\   f_k(\boldsymbol{x})&amp;=f_{k-1}(\boldsymbol{x})+T(\boldsymbol{x};\theta_k) \\   f_k(\boldsymbol{x})&amp;=\sum_{k=1}^KT(\boldsymbol{x}; \theta_k)\end{aligned}\]</span></p><p>在第 k 步，给定当前模型 <span class="math inline">\(f_{k-1}(\boldsymbol{x})\)</span> 须求解</p><p><span class="math display">\[    \hat{\theta}_k=\arg\min_{\theta_k} \sum_{i=1}^M L(y^{(i)}, f_{k-1}(\boldsymbol{x}) + T(\boldsymbol{x}^{(i)};\theta_k))\]</span></p><p>若采用平方误差损失函数</p><p><span class="math display">\[    L(y, f(\boldsymbol{x})) = (y-f(\boldsymbol{x}))^2\]</span></p><p><span class="math display">\[\begin{aligned}    L(y, f_{k-1}(\boldsymbol{x})+ T(\boldsymbol{x}^{(i)};\theta_k))    &amp;=[y - f_{k-1}(\boldsymbol{x})-T(\boldsymbol{x}^{(i)};\theta_k)]^2  \\    &amp;=[r-T(\boldsymbol{x}^{(i)};\theta_k)]^2\end{aligned}\]</span></p><p>其中 <span class="math inline">\(r=y-f_{k-1}(\boldsymbol{x})\)</span> 即为残差</p><h2 id="gbdt"><strong>GBDT</strong></h2><p>Adaboost 算法使用指数损失函数，BDT 使用平方损失函数。这两类损失函数在平方算法中都是比较容易优化的。但是一般的损失函数可能就没有类似的性质。因此有人提出了梯度提升的概念，即利用损失函数的负梯度在当前模型的值作为回归问题提升树算法中残差的近似。即为梯度提升树 (Gradient Boostes Decision Tree).</p><p>GDBT其基本原理和残差树类似，基学习器是基于CART算法的回归树，模型依旧为加法模型、学习算法为前向分步算法。不同的是，GDBT没有规定损失函数的类型，设损失函数为 <span class="math inline">\(L(y,f(x))\)</span> 。前向加法算法的每一步都是拟合损失函数的负梯度。</p><p><span class="math display">\[    -[\frac{\partial L(y^{(i)},f(\boldsymbol{x}^{(i)}))}{\partial f(\boldsymbol{x}^{(i)})}]_{f(\boldsymbol{x})=f_{k-1}(\boldsymbol{x}) \approx r_{m,i}}\]</span></p><p>算法：</p><hr><p>输入: 训练集 <span class="math inline">\(D = \{(\boldsymbol{x}^{(1)}, y^{(1)}), (\boldsymbol{x}^{(2)}, y^{(2)}), ... , (\boldsymbol{x}^{(m)}, y^{(m)})\}\)</span><br>    损失函数 <span class="math inline">\(L(y, f(\boldsymbol{x}))\)</span><br>输出: 提升树 <span class="math inline">\(\hat{f}(\boldsymbol{x})\)</span><br>  (1) 初始化模型 <span class="math inline">\(f_0(\boldsymbol{x})=\arg\min_c\sum_{i=1}^ML(y^{(i)},c)\)</span>， <span class="math inline">\(c\)</span>为常数<br>  (2) 循环训练 k 个模型 k = 1, 2, 3,...,K<br>    (a) 计算残差 i 对于 i=1, 2,... ,K</p><p><span class="math display">\[r_{k, j}=-[\frac{\partial L(y^{(i)},f(\boldsymbol{x}^{(i)}))}{\partial f(\boldsymbol{x}^{(i)})}]_{f(\boldsymbol{x})=f_{k-1}(\boldsymbol{x})}\]</span></p><p>    (b) 拟合残差 <span class="math inline">\(r_{k, j}\)</span> 学习一个回归树，得到第 k 颗树的叶节点区域 <span class="math inline">\(R_{k,j}\)</span>，<span class="math inline">\(j=1,2,3,...,J\)</span><br>    (c) 对 <span class="math inline">\(j=1,2,...,J\)</span> 计算</p><p><span class="math display">\[c_{k,j}=\arg\min_c\sum_{ x^{(i)}\in R_{k,j}}L(y^{(i)},f_{k-1}(\boldsymbol{x}^{(i)})+c)\]</span></p><p>    (d) 更新模型</p><p><span class="math display">\[f_k(\boldsymbol{x})=f_{k-1}(\boldsymbol{x})+\sum_{j=1}^JC_{k,j}\mathbb{I}(\boldsymbol{x} \in R_{k,j})\]</span></p><p>  (3) 得到回归提升树</p><p><span class="math display">\[    \hat{f}(\boldsymbol{x})=f_K(\boldsymbol{x})=\sum_{k=1}^K\sum_{j=1}^J C_{k,j}\mathbb{I}(\boldsymbol{x} \in R_{k,j})\]</span></p><hr><p>当损失函数为 <span class="math inline">\(l(y,\hat{y})=\frac{1}{2}(y-\hat{y})^2\)</span> 时，负梯度为 <span class="math inline">\(-[\frac{\partial L(y, \hat{y})}{\partial\hat{y}}]=(y-\hat{y})\)</span>，即为残差。</p><p>如果一个函数到达极小值，那么其梯度值一定为零；当函数没有到达最小值的时候，我们每次都选择梯度的反方向走，这样可以最快的到达极小值。这也就是GDBT的思想。</p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Boosting </tag>
            
            <tag> 集成学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Boosting算法族一 Adaboost</title>
      <link href="/2017/10/09/Boosting1/"/>
      <url>/2017/10/09/Boosting1/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><strong>前言</strong></h2><p>Boosting 是一族可将弱学习器提升为强学习器的算法。这族算法的工作机制类似：先从初始训练集训练一个基学习器，再根据基学习器的表现对训练样本分布进行调整，使得先前基学习器做错的样本受到更多关注，然后基于调整过后的分布来训练下一个基学习器，如此反复进行，直到基学习器数目达到事先指定的值 <span class="math inline">\(T\)</span> ,最终将这 <span class="math inline">\(T\)</span> 个基学习器进行加权组合。</p><a id="more"></a><h2 id="加法模型和向前分布算法"><strong>加法模型和向前分布算法</strong></h2><p>Boosting算法族的基本特点是:</p><ul><li>1.加法模型</li><li>2.向前分步算法</li></ul><p>加法模型的意思是最终得到的模型，是若干个基函数的加和。</p><p><span class="math display">\[f(x) = \sum_{m=1}^{M}\beta_mb(x;\gamma_m)\]</span></p><p>其中，<span class="math inline">\(b(x;\gamma_m)\)</span> 称为基函数，<span class="math inline">\(\gamma_m\)</span> 为第 <span class="math inline">\(ｍ\)</span> 个基函数的参数，<span class="math inline">\(\beta_m\)</span> 为基函数的系数。</p><p>在给定训练数据和损失函数 <span class="math inline">\(L(y,f(x))\)</span> 的条件下学习加法模型 <span class="math inline">\(f(x)\)</span> 就成为风险极小化问题，即损失函数极小化问题</p><p><span class="math display">\[\min_{\beta_m,\gamma_m}\sum_{i=1}^{N}L(y_i, \sum_{m=1}^{M}\beta_mb(x_i;\gamma_m))\]</span></p><p>随后该问题可以简化为:　从前向后，每一步只学习一个基函数及其系数，逐渐逼近上式，即: 每步只优化如下损失函数:</p><p><span class="math display">\[ \min_{\beta, \gamma} \sum_{i=1}^{N}L(y_i, \beta b(x_i;\gamma))\]</span></p><hr><p>输入: <span class="math inline">\(T=\{\}\)</span><br>损失函数: <span class="math inline">\(L(y,f(x))\)</span><br>基函数集: <span class="math inline">\(\{b(x;\gamma)\}\)</span> 输出: 加法模型 <span class="math inline">\(f(x)\)</span><br>算法步骤:<br>  初始化 <span class="math inline">\(f_0(x)=0\)</span><br>  for <span class="math inline">\(m=1, 2, 3, ... ,M\)</span> do<br>    极小化损失函数 <span class="math inline">\(\arg\min_{\beta,\gamma}\sum_{i=1}^{N}L(y_i,f_{m-1}(x_i) + \beta b(x_i;\gamma))\)</span><br>    更新 <span class="math inline">\(f_m(x) = f_{m-1}(x) + \beta_m b(x;\gamma_m)\)</span><br>  end for<br>输出: 加法模型 <span class="math inline">\(f(x)=f_M(x)=\sum_{m=1}^{M}\beta_m b(x;\gamma_m)\)</span></p><hr><p>向前分布算法是加法模型的一个学习方法。</p><h2 id="adaboost"><strong>AdaBoost</strong></h2><h3 id="adaboost-算法"><strong>AdaBoost 算法</strong></h3><p>AdaBoost 是Boosting家族一个比较著名的代表。基本算法如下（其中 <span class="math inline">\(y_i \in \{-1, +1\}\)</span>，<span class="math inline">\(f\)</span> 是真实函数）:</p><hr><p><strong>输入:</strong> 训练集 <span class="math inline">\(D=\{({\boldsymbol x}_1,y_1),({\boldsymbol x}_2,y_2),...,({\boldsymbol x}_m,y_m)\}\)</span><br>    基学习算法 <span class="math inline">\(\mathfrak{L}\)</span><br>    训练轮数 <span class="math inline">\(T\)</span><br><strong>过程:</strong><br><span class="math inline">\(\mathcal{D}_1 = \frac{1}{m}\)</span><br>for <span class="math inline">\(t=1,2,...,T\)</span> do<br>   <span class="math inline">\(h_t=\mathfrak{L}(D, \mathcal{D}_t)\)</span><br>   <span class="math inline">\(\epsilon_t=P_{x\sim\mathcal{D}_t}(h_t({\boldsymbol x}) \neq f(\boldsymbol x))\)</span><br>   if <span class="math inline">\(\epsilon_t &gt; 0.5\)</span> then break<br>   <span class="math inline">\(\alpha_t=\frac{1}{2}ln(\frac{1-\epsilon_t}{\epsilon_t})\)</span><br>   <span class="math inline">\(\begin{aligned} \mathcal{D}_{t+1}({\boldsymbol x}) = \frac{\mathcal{D}_t({\boldsymbol x})}{Z_t} \times\begin{cases}  exp(-\alpha_t) \quad if h_t(\boldsymbol x) = f(\boldsymbol x)\\  exp(\alpha_t) \quad if h_t(\boldsymbol x) \neq f(\boldsymbol x) \end{cases}  = \frac{\mathcal{D}_t({\boldsymbol x})exp(-\alpha_t f({\boldsymbol x})h_t({\boldsymbol x}))}{Z_t} \end{aligned}\)</span><br>end for<br><strong>输出:</strong> <span class="math inline">\(H(\boldsymbol x)=sign(\sum_{t=1}^{T}\alpha_th_t({\boldsymbol x}))\)</span></p><hr><h3 id="adaboost-算法的推导"><strong>Adaboost 算法的推导</strong></h3><p>AdaBoost 训练学习器的线性组合 <span class="math display">\[    H(\boldsymbol{x})=\sum_{t=1}^{T}\alpha_th_t(\boldsymbol{x})    \tag{1}\]</span> 来最小化指数损失函数 (exponential loss function) <span class="math display">\[    \ell_{exp}(H|\mathcal{D})=\mathbb{E}_{x\sim\mathcal{D}}    [e^{-f(\boldsymbol{x})H(\boldsymbol{x})}]    \tag{2}\]</span> 若 <span class="math inline">\(H(\boldsymbol{x})\)</span> 能另指数损失函数最小化，则考虑式 <span class="math inline">\((2)\)</span> 对 <span class="math inline">\(H(\boldsymbol{x})\)</span> 的偏导 <span class="math display">\[    \frac{\partial\ell_{exp}(H|\mathcal{D})}{\partial H(\boldsymbol{x})}=-e^{-H(\boldsymbol{x})}P(f(\boldsymbol{x})=1|\boldsymbol{x})+e^{H(\boldsymbol{x})}P(f(\boldsymbol{x}) = -1 | \boldsymbol{x})    \tag{3}\]</span> 另式 <span class="math inline">\((3)\)</span> 为零可解得 <span class="math display">\[    H(\boldsymbol{x})=\frac{1}{2}ln\frac{P(f(\boldsymbol{x})=1|\boldsymbol{x})}{P(f(\boldsymbol{x}) = -1 | \boldsymbol{x})}    \tag{4}\]</span> 因此，有 <span class="math display">\[    \begin{aligned}        sign(H(\boldsymbol{x}))&amp;=sign(\frac{1}{2}ln\frac{P(f(\boldsymbol{x})=1|\boldsymbol{x})}{P(f(\boldsymbol{x}) = -1 | \boldsymbol{x})})\\        &amp;=            \begin{cases}                1 &amp;\quad P(f(\boldsymbol{x})=1|\boldsymbol{x}) &gt; P(f(\boldsymbol{x})=-1|\boldsymbol{x}) \\                -1 &amp;\quad P(f(\boldsymbol{x})=1|\boldsymbol{x}) &lt; P(f(\boldsymbol{x})=-1|\boldsymbol{x})            \end{cases} \\        &amp;= \arg\min_{\mathcal{y}\in\{-1.1\}}P(f({x})=y|\boldsymbol{x})    \end{aligned}    \tag{5}\]</span> 这意味着 <span class="math inline">\(sign(H(\boldsymbol{x}))\)</span> 达到了贝叶斯最优错误率。换言之，若指数函数最小化，则分类错误率也将最小化。这说明指数损失函数是分类任务原本 <span class="math inline">\(0/1\)</span> 损失函数的一致的 (consistent) 替代损失函数。该函数连续可微，数学性质更好，因此我们用它替代 <span class="math inline">\(0/1\)</span> 损失函数作为优化目标。</p><p>在AdaBoost算法中，关于 <span class="math inline">\(\alpha_t\)</span> ，<span class="math inline">\(h_t\)</span> 基于 <span class="math inline">\(\mathcal{D}_t\)</span> 产生后，该基分类器权重 <span class="math inline">\(\alpha_t\)</span> 应使 <span class="math inline">\(\alpha_th_t\)</span> 最小化损失函数。 <span class="math display">\[    \begin{aligned}        \ell_{exp}(\alpha_th_t|\mathcal{D}_t)&amp;=\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}_t}[e^{-f(\boldsymbol{x})\alpha_th_t(\mathcal{x})}] \\        &amp;=\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}_t}[e^{-\alpha_t}\mathbb{I}(f(\boldsymbol{x})=h_t(\boldsymbol{x}))+e^{\alpha_t}\mathbb{I}(f(\boldsymbol{x})\neq h_t(\boldsymbol{x}))] \\        &amp;=e^{-\alpha_t}P_{\boldsymbol{x}\sim\mathcal{D}_t}(f(\boldsymbol{x})=h_t(\boldsymbol{x})) + e^{\alpha_t}P_{\boldsymbol{x}\sim\mathcal{D}_t}(f(\boldsymbol{x})\neq h_t(\boldsymbol{x}))\\        &amp;=e^{-\alpha_t}(1-\epsilon_t)+e^{\alpha_t}\epsilon_t    \end{aligned}    \tag{6}\]</span> 其中 <span class="math inline">\(\epsilon_t=P_{\boldsymbol{x}\sim\mathcal{D}_t}(h_t(\boldsymbol{x})\neq f(\boldsymbol{x})\)</span> 则其导数 <span class="math display">\[    \frac{\partial\ell_{exp}(\alpha_th_t|\mathcal{D}_t)}{\partial\alpha_t}=-e^{-\alpha_t}(1-\epsilon_t)+e^{\alpha_t}\epsilon_t    \tag{7}\]</span> 令其为零可得到算法中的权重更新公式 <span class="math display">\[    \alpha_t=\frac{1}{2}ln(\frac{1-\epsilon_t}{\epsilon_t})    \tag{8}\]</span> AdaBoost 在获取 <span class="math inline">\(H_{t-1}\)</span> 之后样本分布将进行调整，使下一轮的 <span class="math inline">\(h_t\)</span> 能够纠正 <span class="math inline">\(H_{t-1}\)</span> 的全部错误，即最小化 <span class="math display">\[    \begin{aligned}        \ell_{exp}(H_{t-1}+h_t|\mathcal{D})        &amp;= \mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}} [e^{-f(\boldsymbol{x})(H_{t-1}(\boldsymbol{x}) + h_t(\boldsymbol{x}))}]\\        &amp;=\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}e^{-f(\boldsymbol{x})h_t(\boldsymbol{x}))}]    \end{aligned}    \tag{9}\]</span> 注意到 <span class="math inline">\(f^2(\boldsymbol{x})=h_t^2(\boldsymbol{x})=1\)</span>，则对 <span class="math inline">\(e^{-f(\boldsymbol{x})h_t(\boldsymbol{x}))}\)</span> 进行泰勒展开。 <span class="math display">\[    \begin{aligned}        \ell_{exp}(H_{t-1}+h_t|\mathcal{D})        &amp;\simeq \mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}(1-f(\boldsymbol{x})h_t(\boldsymbol{x})+\frac{f^2(\boldsymbol{x})h_t^2(\boldsymbol{x})}{2})]\\        &amp;=\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}(1-f(\boldsymbol{x})h_t(\boldsymbol{x})+\frac{1}{2})]    \end{aligned}    \tag{10}\]</span> 于是，理想的基学习器 <span class="math display">\[    \begin{aligned}        h_t(\boldsymbol{x})        &amp;=\mathop{\arg\min}_{h}\ell_{exp}(H_{t-1}+h|\mathcal{D})\\        &amp;=\mathop{\arg\min}_{h}\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}(1-f(\boldsymbol{x})h(\boldsymbol{x})+\frac{1}{2})]\\        &amp;=\mathop{\arg\max}_{h} \mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})} f(\boldsymbol{x})h(\boldsymbol{x})]\\        &amp;=\mathop{\arg\max}_{h} \mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[\frac{e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}}{\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}]} f(\boldsymbol{x})h(\boldsymbol{x})]    \end{aligned}    \tag{11}\]</span> <span class="math inline">\(\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}_t}[e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}]\)</span> 为常数，令 <span class="math inline">\(\mathcal{D}_t\)</span> 表示一个分布 <span class="math display">\[    \mathcal{D}_t(\boldsymbol{x}) = \frac{\mathcal{D}(\boldsymbol{x})e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}}{\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}]}    \tag{12}\]</span> 由数学期望的定义，其等价于令 <span class="math display">\[    \begin{aligned}        h_t(\boldsymbol{x})&amp;=\arg\max_h        \mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[\frac{e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}}{\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}_t}[e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}]} f(\boldsymbol{x})h(\boldsymbol{x})] \\        &amp;=\arg\max_h \mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}_t}[f(\boldsymbol{x})h(\boldsymbol{x})]    \end{aligned}    \tag{13}\]</span> 由于 <span class="math inline">\(f(\boldsymbol{x})h(\boldsymbol{x} \in \{-1, +1\})\)</span> ，有 <span class="math display">\[    f(\boldsymbol{x})h(\boldsymbol{x})=1-2\mathbb{I}(f(\boldsymbol{x}) \neq h(\boldsymbol{x}))    \tag{14}\]</span> 则理想的基学习器 <span class="math display">\[    h_t(\boldsymbol{x})=\arg\min_h    \mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}_t}    [\mathbb{I}(f(\boldsymbol{x}) \neq h(\boldsymbol{x}))]    \tag{15}\]</span> 由此可见，理想的基学习器 <span class="math inline">\(h_t(x)\)</span> 能在 <span class="math inline">\(\mathcal{D}_t\)</span> 下最小化误差。因此弱分类器应基于分布 <span class="math inline">\(\mathcal{D}_t\)</span> 训练，且分类误差应小于 <span class="math inline">\(0.5\)</span> 。这在一定程度上类似于“残差逼近”的思想，考虑到 <span class="math inline">\(\mathcal{D}_t\)</span> 与 <span class="math inline">\(\mathcal{D}_{t+1}\)</span> 的关系，有 <span class="math display">\[    \begin{aligned}        \mathcal{D}_{t+1}(\boldsymbol{x})        &amp;= \frac{\mathcal{D}(\boldsymbol{x})e^{-f(\boldsymbol{x})H_{t}(\boldsymbol{x})}}        {\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t}(\boldsymbol{x})}]}\\        &amp;= \frac{\mathcal{D}(\boldsymbol{x})e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}e^{-f(\boldsymbol{x})\alpha_th_t(\boldsymbol{x})}}        {\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t}(\boldsymbol{x})}]}\\        &amp;=\mathcal{D}_{t}(\boldsymbol{x})e^{-f(\boldsymbol{x})\alpha_th_t(\boldsymbol{x})}        \frac{\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t-1}(\boldsymbol{x})}]}        {\mathbb{E}_{\boldsymbol{x}\sim\mathcal{D}}[e^{-f(\boldsymbol{x})H_{t}(\boldsymbol{x})}]}    \end{aligned}    \tag{16}\]</span> 即为算法中的样本分布更新公式。</p><p>于是由式 <span class="math inline">\((8)\)</span> 和 式 <span class="math inline">\((16)\)</span> 可见，我们从基于加法模型分步向前优化指数损失函数的角度推导出了AdaBoost算法。</p><h3 id="算法特性"><strong>算法特性</strong></h3><p>AdaBoost算法要求基学习器能对特定的数据分布进行学习，这可通过“重赋权法” (re-weighting) 实施，即在训练过程的每一轮中，根据样本分布为每个训练样本重新赋予一个权重。需要注意的是Boosting学习器在每一轮训练都要检查当前生成的基学习器是否满足基本条件 (例如AdaBoost每一轮都要检测基学习器是否比随机猜测好)，一旦条件不满足当前基学习器即被抛弃，且学习过程停止。</p><p>从偏差-方差分解的角度看，Boosting算发主要关注降低偏差，因此Boosting算法族能基于泛化能力相当弱的学习器构建出来很强的集成。</p><h2 id="参考文献"><strong>参考文献</strong></h2><ul><li><a href="http://zh.wikipedia.org/zh-cn/AdaBoost" target="_blank" rel="noopener">Wikipedia上关于AdaBoost的介绍</a></li><li>《机器学习》周志华著，第8章</li><li>《统计学习方法》李航著，第8章</li><li><a href="https://blog.csdn.net/v_JULY_v/article/details/40718799" target="_blank" rel="noopener">Adaboost 算法的原理与推导</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> Boosting </tag>
            
            <tag> 集成学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习算法笔记-决策树</title>
      <link href="/2017/04/10/Decition_tree/"/>
      <url>/2017/04/10/Decition_tree/</url>
      
        <content type="html"><![CDATA[<h2 id="前言">前言</h2><p>决策树（Decision Tree）是一种常见的机器学习方法。决策树基于树形结构进行决策，其每个非叶节点表示一个某属性集上的划分，每个分支代表这个特征属性在某个值域上的输出，每个叶节点则对应一个类别。本文主要总结一些基础的决策树算法。</p><a id="more"></a><h2 id="决策树基本算法">决策树基本算法</h2><p>输入:<br>训练集 <span class="math inline">\(D\)</span> = <span class="math inline">\(\{(x_1, y_1), (x_2, y_2), ..., (x_m, y_m)\}\)</span><br>属性集 <span class="math inline">\(A\)</span> = <span class="math inline">\(\{(a_1, a_2, ..., a_d)\}\)</span></p><p>过程：函数 <span class="math inline">\(TreeGenerate(G, A)\)</span><br>if <span class="math inline">\(D\)</span> 中的样本全属于同一类别 <span class="math inline">\(C\)</span> then<br>  将node标记为 <span class="math inline">\(C\)</span> 类叶节点; return<br>end if<br>if <span class="math inline">\(A\)</span> = <span class="math inline">\(\emptyset\)</span> OR <span class="math inline">\(D\)</span> 中的样本在 <span class="math inline">\(A\)</span> 上的取值相同 then<br>  将node标记为叶节点，类别为 <span class="math inline">\(D\)</span> 中样本最多的一类; return<br>end if<br>从 <span class="math inline">\(A\)</span> 中选择最优化分属性 <span class="math inline">\(a_*\)</span><br>for <span class="math inline">\(a_*\)</span> 的每一个取值 <span class="math inline">\(a_{*}^{v}\)</span> do<br>  为node生成一个分支；令 <span class="math inline">\(D_v\)</span> 表示 <span class="math inline">\(D\)</span> 中在 <span class="math inline">\(a_*\)</span> 上取值为 <span class="math inline">\(a_{*}^{v}\)</span> 的样本子集;<br>  if <span class="math inline">\(D_v\)</span> 为空 then<br>   将分支结点标记为叶节点，其类别标记为 <span class="math inline">\(D\)</span> 中样本最多的类; return<br>  else<br>  以 <span class="math inline">\(TreeGenerate(D_v, A \setminus\{a_*\})\)</span> 为分支结点<br> end if<br>end for</p><h2 id="属性划分">属性划分</h2><p>假定当前样本集合 <span class="math inline">\(D\)</span> 中第 <span class="math inline">\(k\)</span> 类样本所占比例为 <span class="math inline">\(p_k\)</span> (<span class="math inline">\(k\)</span> = 1,2, ... ,<span class="math inline">\(\mathcal{|Y|}\)</span>)</p><p>1.信息熵 <span class="math display">\[Ent(D) = - \sum_{k=1}^{|\mathcal{Y}|}p_klog_2p_k\]</span> 2.信息增益 <span class="math display">\[ Gain(D, a) = Ent(D)-\sum_{v=1}^{V}\frac{\lvert D^v\rvert}{\lvert D \rvert}Ent(D^v)\]</span></p><p>3.信息增益率 <span class="math display">\[Gain\_ratio = \frac{Gain(D, a)}{IV(a)}\]</span> <span class="math display">\[IV(a) = -\sum_{v=1}^{V}\frac{|D^v|}{|D|}log_2\frac{|D^v|}{|D|}\]</span> 4.基尼系数 <span class="math display">\[Gini(D)=\sum_{k=1}^{|\mathcal{Y}|}\sum_{k^{`} \neq k}p_k p_{k^`}\]</span> <span class="math display">\[Gini\_index(D,a) = \sum_{v=1}^{V}\frac{|D^v|}{|D|}Gini(D^v)\]</span></p>]]></content>
      
      
      <categories>
          
          <category> Algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Algorithm </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
